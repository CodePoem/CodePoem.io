<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>梦半觉</title>
  
  <subtitle>大梦谁先觉，平生我自知~</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://codepoem.github.io/"/>
  <updated>2021-06-11T01:21:00.736Z</updated>
  <id>https://codepoem.github.io/</id>
  
  <author>
    <name>CodePoem</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>简析LRU</title>
    <link href="https://codepoem.github.io/2021/06/11/%E7%AE%80%E6%9E%90LRU/"/>
    <id>https://codepoem.github.io/2021/06/11/简析LRU/</id>
    <published>2021-06-11T01:21:00.736Z</published>
    <updated>2021-06-11T01:21:00.736Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LRU"><a href="#LRU" class="headerlink" title="LRU"></a>LRU</h1><p>最近最少使用算法。</p><h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><ul><li><p>-要求查找快，插入快，删除快，有顺序之分。哈希表查找快，但是数据无固定顺序；链表有顺序之分，插入删除快，但是查找慢。所以结合一下，形成一种新的数据结构：哈希链表。</p></li><li><p>按顺序插入 ，所以需要双向链表。</p></li><li><p>LinkedHashMap，使用 accessOrder=true 基于顺序访问，元素访问后被移动到末尾。</p></li></ul><h2 id="自己动手实现LRU"><a href="#自己动手实现LRU" class="headerlink" title="自己动手实现LRU"></a>自己动手实现LRU</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> key, val;</span><br><span class="line">    <span class="keyword">public</span> Node next, prev;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.key = k;</span><br><span class="line">        <span class="keyword">this</span>.val = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DoubleList</span> </span>&#123;  </span><br><span class="line">    <span class="comment">// 在链表头部添加节点 x，时间 O(1)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(Node x)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除链表中的 x 节点（x 一定存在）</span></span><br><span class="line">    <span class="comment">// 由于是双链表且给的是目标 Node 节点，时间 O(1)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Node x)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除链表中最后一个节点，并返回该节点，时间 O(1)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">removeLast</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回链表长度，时间 O(1)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> </span>&#123;</span><br><span class="line">    <span class="comment">// key -&gt; Node(key, val)</span></span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;Integer, Node&gt; map;</span><br><span class="line">    <span class="comment">// Node(k1, v1) &lt;-&gt; Node(k2, v2)...</span></span><br><span class="line">    <span class="keyword">private</span> DoubleList cache;</span><br><span class="line">    <span class="comment">// 最大容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> cap;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cap = capacity;</span><br><span class="line">        map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        cache = <span class="keyword">new</span> DoubleList();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!map.containsKey(key))</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> val = map.get(key).val;</span><br><span class="line">        <span class="comment">// 利用 put 方法把该数据提前</span></span><br><span class="line">        put(key, val);</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 先把新节点 x 做出来</span></span><br><span class="line">        Node x = <span class="keyword">new</span> Node(key, val);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(key)) &#123;</span><br><span class="line">            <span class="comment">// 删除旧的节点，新的插到头部</span></span><br><span class="line">            cache.remove(map.get(key));</span><br><span class="line">            cache.addFirst(x);</span><br><span class="line">            <span class="comment">// 更新 map 中对应的数据</span></span><br><span class="line">            map.put(key, x);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (cap == cache.size()) &#123;</span><br><span class="line">                <span class="comment">// 删除链表最后一个数据</span></span><br><span class="line">                Node last = cache.removeLast();</span><br><span class="line">                map.remove(last.key);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 直接添加到头部</span></span><br><span class="line">            cache.addFirst(x);</span><br><span class="line">            map.put(key, x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LruCache"><a href="#LruCache" class="headerlink" title="LruCache"></a>LruCache</h2><p>Android SDK里有提供。</p><h2 id="DiskLruCache"><a href="#DiskLruCache" class="headerlink" title="DiskLruCache"></a>DiskLruCache</h2><p>Android SDK里没有提供，AOSP源码有。</p><p>很多文件操作都采用了事务的处理方式，即修改文件前先写入一个同名的 tmp 文件，当所有内容写完后再将 tmp 文件的扩展名去掉以覆盖原有文件，这样做的好处就是不会因为应用的异常退出或 Crash 而出现数据损坏，保证了原有文件的完整性。</p><p>DiskLruCache 在操作文件的时候使用 journal 文件 来记录操作日志。</p><p>journal头：</p><ul><li>第一行是固定的字符串“libcore.io.DiskLruCache”，标志着使用的是DiskLruCache技术。</li><li>第二行是DiskLruCache的版本号。</li><li>第三行是应用程序的版本号。</li><li>第四行是valueCount</li><li>第五行是一个空行。</li></ul><p>DIRTY 脏数据行 正在写入<br>CLEAN 洗净脏数据行 写入成功 行末尾加上该条缓存数据的大小，以字节为单位。<br>REMOVE 移除脏数据行 写入失败</p><p>READ 读取数据行</p><p>每一行DIRTY的key，后面都应该有一行对应的CLEAN或者REMOVE的记录，否则这条数据就是“脏”的。<br>redundantOpCount变量来记录用户操作的次数，每执行一次写入、读取或移除缓存的操作，这个变量值都会加1，当变量值达到2000的时候就会触发重构journal的事件，这时会自动把journal中一些多余的、不必要的记录全部清除掉，保证journal文件的大小始终保持在一个合理的范围内。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;LRU&quot;&gt;&lt;a href=&quot;#LRU&quot; class=&quot;headerlink&quot; title=&quot;LRU&quot;&gt;&lt;/a&gt;LRU&lt;/h1&gt;&lt;p&gt;最近最少使用算法。&lt;/p&gt;
&lt;h2 id=&quot;基本原理&quot;&gt;&lt;a href=&quot;#基本原理&quot; class=&quot;headerlink&quot; tit
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>简析Glide</title>
    <link href="https://codepoem.github.io/2021/06/11/%E7%AE%80%E6%9E%90Glide/"/>
    <id>https://codepoem.github.io/2021/06/11/简析Glide/</id>
    <published>2021-06-11T01:21:00.736Z</published>
    <updated>2021-06-11T01:21:00.736Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Glide"><a href="#Glide" class="headerlink" title="Glide"></a>Glide</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Glide.with(context)</span><br><span class="line">    .load(myUrl)</span><br><span class="line">    .into(imageView);</span><br></pre></td></tr></table></figure><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><h3 id="传入ApplicationContext"><a href="#传入ApplicationContext" class="headerlink" title="传入ApplicationContext"></a>传入ApplicationContext</h3><p>Application对象的生命周期即应用程序的生命周期，因此Glide并不需要做什么特殊的处理，它自动就是和应用程序的生命周期是同步的。</p><h3 id="传入非ApplicationContext"><a href="#传入非ApplicationContext" class="headerlink" title="传入非ApplicationContext"></a>传入非ApplicationContext</h3><p>无视图的Fragment接管LifeCycle。</p><h2 id="缓存机制"><a href="#缓存机制" class="headerlink" title="缓存机制"></a>缓存机制</h2><h3 id="内存缓存"><a href="#内存缓存" class="headerlink" title="内存缓存"></a>内存缓存</h3><p>LruCache算法（Least Recently Used），也叫近期最少使用算法。算法原理就是把最近使用的对象用强引用存储在LinkedHashMap中，并且把最近最少使用的对象在缓存值达到预设定值之前从内存中移除。</p><p>弱引用缓存正在使用的图片，可以保护这些图片不会被LruCache算法回收掉。</p><h3 id="硬盘缓存"><a href="#硬盘缓存" class="headerlink" title="硬盘缓存"></a>硬盘缓存</h3><p>DiskLruCache，journal 文件。</p><h2 id="Bitmap采样和复用机制"><a href="#Bitmap采样和复用机制" class="headerlink" title="Bitmap采样和复用机制"></a>Bitmap采样和复用机制</h2><h3 id="采样"><a href="#采样" class="headerlink" title="采样"></a>采样</h3><ol><li>计算缩放因子</li><li>获取采样类型 内存优先（比要求的尺寸小）/ 质量优先（比要求的尺寸大）</li><li>计算整型的缩放因子</li><li>将整型的缩放因子转成2的幂</li></ol><h3 id="复用机制"><a href="#复用机制" class="headerlink" title="复用机制"></a>复用机制</h3><p>BitmapPool，默认具体实现 LruBitmapPool。</p><p>不光对开销较大的 Bitmap 进行了复用，就连为了复用 Bitmap 时重复申请的 Key 对象都进行了复用，尽可能的减少了对象的创建开销，保证了应用的流畅性。</p><h4 id="复用的前提"><a href="#复用的前提" class="headerlink" title="复用的前提"></a>复用的前提</h4><p>inMutable = true<br>inBitmap 指定复用的Bitmap</p><p>在Android 4.4之前，仅支持相同大小的bitmap，inSampleSize必须为1，而且必须采用 jpeg 或 png 格式。</p><p>在Android 4.4之后只有一个限制，就是被复用的 bitmap 尺寸要大于新的bitmap，简单来说就是大图可以给小图复用。</p><h4 id="复用实现"><a href="#复用实现" class="headerlink" title="复用实现"></a>复用实现</h4><p>根据特定的缓存策略，根据系统版本如判断采用完全匹配或者大小匹配，从缓存池获取到 Dirty 的 Bitmap，使用 reconfigure 和 eraseColor(Color.TRANSPARENT) 来 clean 这个 Bitmap。</p><ol><li>加入复用池时机：外部加载完或者回收调用放入</li><li>获取缓存时机：加载图片前</li><li>删除，每次操作都会判断是否需要删除多余的缓存</li></ol><h2 id="线程池管理"><a href="#线程池管理" class="headerlink" title="线程池管理"></a>线程池管理</h2><ul><li>diskCacheExecutor 本地缓存任务 newDiskCacheBuilder corePoolSize=maximumPoolSize=1</li><li>sourceExecutor 资源获取任务  corePoolSize=maximumPoolSize=处理器数量和固定值4之间区最小</li><li>sourceUnlimitedExecutor 资源获取不限制任务 corePoolSize=0 maximumPoolSize=Integer.MAX_VALUE 10ms超时 SynchronousQueue</li><li>animationExecutor Gif加载任务 corePoolSize=在处理器数量和固定值4之间区最小 maximumPoolSize=1或2</li></ul><p>除了 sourceUnlimitedExecutor 都使用了 PriorityBlockingQueue 来作为等待队列。</p><h2 id="使用自定义模块解耦"><a href="#使用自定义模块解耦" class="headerlink" title="使用自定义模块解耦"></a>使用自定义模块解耦</h2><ul><li><p>setMemoryCache()<br>用于配置 Glide 的内存缓存策略，默认配置是 LruResourceCache。</p></li><li><p>setBitmapPool()<br>用于配置 Glide 的Bitmap缓存池，默认配置是 LruBitmapPool。</p></li><li><p>setDiskCache()<br>用于配置 Glide 的硬盘缓存策略，默认配置是 InternalCacheDiskCacheFactory。</p></li><li><p>setDiskCacheService()<br>用于配置 Glide 读取缓存中图片的异步执行器，默认配置是 FifoPriorityThreadPoolExecutor，也就是先入先出原则。</p></li><li><p>setResizeService()<br>用于配置 Glide 读取非缓存中图片的异步执行器，默认配置也是 FifoPriorityThreadPoolExecutor。</p></li><li><p>setDecodeFormat()<br>用于配置 Glide 加载图片的解码模式，默认配置是 RGB_565。</p></li></ul><p>Glide 3:</p><ol><li>自定义模块类，实现 GlideModule 。</li><li>AndroidManifest.xml 中配置</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">manifest</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">application</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta-data</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:name</span>=<span class="string">"com.example.glidetest.MyGlideModule"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:value</span>=<span class="string">"GlideModule"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure><p>解析 AndroidManifest.xml 中 value 为 GlideModule 的 meta-data ,反射实例化自定义模块类。Glide 在实例化的时候会先遍历模块列表应用配置。</p><p>Glide 4:</p><ol><li>自定义模块类，继承 AppGlideModule 。</li><li>自定义模块类上添加 @GlideModule 注解。</li></ol><p>注解处理器 auto-service + JavaPoet</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Glide&quot;&gt;&lt;a href=&quot;#Glide&quot; class=&quot;headerlink&quot; title=&quot;Glide&quot;&gt;&lt;/a&gt;Glide&lt;/h1&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>简析LeakCanary</title>
    <link href="https://codepoem.github.io/2021/06/11/%E7%AE%80%E6%9E%90LeakCanary/"/>
    <id>https://codepoem.github.io/2021/06/11/简析LeakCanary/</id>
    <published>2021-06-11T01:21:00.736Z</published>
    <updated>2021-06-11T01:21:00.736Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LeakCanary"><a href="#LeakCanary" class="headerlink" title="LeakCanary"></a>LeakCanary</h1><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>添加依赖（release有no-op版）然后在 Application 初始化。</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">  debugImplementation <span class="string">'com.squareup.leakcanary:leakcanary-android:1.X'</span></span><br><span class="line">  releaseImplementation <span class="string">'com.squareup.leakcanary:leakcanary-android-no-op:1.X'</span></span><br><span class="line">  <span class="comment">// Optional, if you use support library fragments:</span></span><br><span class="line">  debugImplementation <span class="string">'com.squareup.leakcanary:leakcanary-support-fragment:1.X'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleApplication</span> <span class="keyword">extends</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate();</span><br><span class="line">    <span class="keyword">if</span> (LeakCanary.isInAnalyzerProcess(<span class="keyword">this</span>)) &#123;</span><br><span class="line">        <span class="comment">// This process is dedicated to LeakCanary for heap analysis.</span></span><br><span class="line">        <span class="comment">// You should not init your app in this process.</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LeakCanary.install(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">// Normal app init code...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><h3 id="Watch"><a href="#Watch" class="headerlink" title="Watch"></a>Watch</h3><p>Activity：</p><p>application.registerActivityLifecycleCallbacks 覆写 onActivityDestroyed</p><p>watch（）使用 WeakReference + ReferenceQueue监听对象回收情况</p><p>watchedObjects（LinkedHashMap&lt;key, KeyedWeakReference&gt;）  watch() 方法传进来的引用，尚未判定为泄露<br>queue（ReferenceQueue） 怀疑泄漏的对象列表</p><p>以 UUID.randomUUID().toString() 为key 构造 KeyedWeakReference（关联ReferenceQueue） 存入watchedObjects。</p><p><strong><em>弱引用一旦变得弱可达，就会立即入队 ReferenceQueue。这将在 finalization 或者 GC 之前发生。</em></strong></p><p>watch方法最后会调用moveToRetained（）</p><h3 id="Dump"><a href="#Dump" class="headerlink" title="Dump"></a>Dump</h3><h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>计算了到GC Roots的最短强引用路径。</p><h2 id="2-0版本"><a href="#2-0版本" class="headerlink" title="2.0版本"></a>2.0版本</h2><h3 id="不需要在Application-初始化"><a href="#不需要在Application-初始化" class="headerlink" title="不需要在Application 初始化"></a>不需要在Application 初始化</h3><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">  debugImplementation <span class="string">'com.squareup.leakcanary:leakcanary-android:2.X'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ContentProvider实现"><a href="#ContentProvider实现" class="headerlink" title="ContentProvider实现"></a>ContentProvider实现</h4><p>leakcanary-android-process 模块的 AndroidManifest.xml 文件:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">manifest</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">package</span>=<span class="string">"com.squareup.leakcanary"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">application</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">service</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:name</span>=<span class="string">"leakcanary.internal.HeapAnalyzerService"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:exported</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:process</span>=<span class="string">":leakcanary"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">provider</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:name</span>=<span class="string">"leakcanary.internal.AppWatcherInstaller$LeakCanaryProcess"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:authorities</span>=<span class="string">"$&#123;applicationId&#125;.leakcanary-process.installer"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:process</span>=<span class="string">":leakcanary"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:exported</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure><p>看看AppWatcherInstaller干了啥：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">sealed</span> <span class="class"><span class="keyword">class</span> <span class="title">AppWatcherInstaller</span> : <span class="type">ContentProvider</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * [MainProcess] automatically sets up the LeakCanary code that runs in the main app process.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">internal</span> <span class="class"><span class="keyword">class</span> <span class="title">MainProcess</span> : <span class="type">AppWatcherInstaller</span></span>()</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * When using the `leakcanary-android-process` artifact instead of `leakcanary-android`,</span></span><br><span class="line"><span class="comment">   * [LeakCanaryProcess] automatically sets up the LeakCanary code</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">internal</span> <span class="class"><span class="keyword">class</span> <span class="title">LeakCanaryProcess</span> : <span class="type">AppWatcherInstaller</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">      <span class="keyword">super</span>.onCreate()</span><br><span class="line">      AppWatcher.config = AppWatcher.config.copy(enabled = <span class="literal">false</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> application = context!!.applicationContext <span class="keyword">as</span> Application</span><br><span class="line">    InternalAppWatcher.install(application)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用加载顺序实现自动注入：</p><p>Application-&gt;attachBaseContext =====&gt; ContentProvider-&gt;onCreate =====&gt; Application-&gt;onCreate =====&gt; Activity-&gt;onCreate</p><p>优点：实现”免侵入”集成，不需要手动初始化。<br>缺点：无法更改初始化时机（App启动优化按需延迟初始化第三方库对这样的集成方式就无能为力了）。考虑到 LeakCanary 是开发 debug 阶段使用的，也无可厚非。一般的 SDK 还是不建议使用这种方式。</p><h3 id="添加默认对Fragment的支持"><a href="#添加默认对Fragment的支持" class="headerlink" title="添加默认对Fragment的支持"></a>添加默认对Fragment的支持</h3><p>Fragment：</p><p>Android O 版本 androidx 都具备对 Fragment 生命周期的监听功能。</p><p>application.registerActivityLifecycleCallbacks 覆写 onActivityCreated<br>然后 fragmentManager.registerFragmentLifecycleCallbacks 覆写 onFragmentViewDestroyed() onFragmentDestroyed()</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;LeakCanary&quot;&gt;&lt;a href=&quot;#LeakCanary&quot; class=&quot;headerlink&quot; title=&quot;LeakCanary&quot;&gt;&lt;/a&gt;LeakCanary&lt;/h1&gt;&lt;h2 id=&quot;使用&quot;&gt;&lt;a href=&quot;#使用&quot; class=&quot;headerli
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>简析OkHttp</title>
    <link href="https://codepoem.github.io/2021/06/11/%E7%AE%80%E6%9E%90OkHttp/"/>
    <id>https://codepoem.github.io/2021/06/11/简析OkHttp/</id>
    <published>2021-06-11T01:21:00.736Z</published>
    <updated>2021-06-11T01:21:00.736Z</updated>
    
    <content type="html"><![CDATA[<h1 id="OkHttp"><a href="#OkHttp" class="headerlink" title="OkHttp"></a>OkHttp</h1><p>是对 Socket 的封装。URLConnection 在4.4以后底层也使用了 OkHttp。</p><p>Android源码中 /external/okhttp/jarjar-rules.txt 中表示com.squareup开关的包会在编译时打包成com.android开头的包。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rule com.squareup.** com.android.@1</span><br><span class="line">rule okio.** com.android.okio.@1</span><br></pre></td></tr></table></figure><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">String url = <span class="string">"http://www.xxx.com"</span>;</span><br><span class="line"><span class="comment">//  生成 OkHttpClient 实例对象</span></span><br><span class="line">OkHttpClient okHttpClient = <span class="keyword">new</span> OkHttpClient();</span><br><span class="line"><span class="comment">//  生成 Request 对象</span></span><br><span class="line">Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">    .url(url)</span><br><span class="line">    .post(RequestBody.create(MediaType.parse(<span class="string">"application/json; charset=utf-8"</span>),<span class="string">"test content"</span>))</span><br><span class="line">    .build();</span><br><span class="line"><span class="comment">//  生成 Call 对象</span></span><br><span class="line">Call call = okHttpClient.newCall(request);</span><br><span class="line"></span><br><span class="line">call.enqueue(<span class="keyword">new</span> Callback() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(@NonNull Call call, @NonNull IOException e)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(@NonNull Call call, @NonNull Response response)</span>  </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><ol><li><p>创建请求对象。 (url, method, headers, body, tags)–&gt; Request–&gt; Call</p></li><li><p>线程池分发请求。同步使用call.excute(),异步使用call.enqueue()请求事件队列, 都交给 Dispatcher 分发， enqueue–&gt;Runnable–&gt;ThreadPoolExecutor</p></li><li><p>递归 Interceptor 拦截器，发送请求。 getResponseWithInterceptorChain()，InterceptorChain</p></li><li><p>请求回调，数据解析。  Respose –&gt; (code,message,requestBody)</p></li></ol><p>不管是异步还是同步，都是一样的三部曲:</p><ol><li>加入到 Dispatche r里面的同步(或异步)队列。</li><li>执行 getResponseWithInterceptorChain 方法。（只不过同步操作是直接运行了 getResponseWithInterceptorChain 方法，而异步是通过线程池执行R unnabl e再去执行 getResponseWithInterceptorChain 方法）</li><li>从 Dispatcher 里面的同步(或异步)队列移除。</li></ol><p>Dispatcher 内部维护3个队列及1个线程池:</p><ul><li>readyAsyncCalls</li></ul><p>待访问请求队列，里面存储准备执行的请求。</p><ul><li>runningSyncCalls</li></ul><p>同步请求队列，正在执行的请求，包含已经取消但是还没有结束的请求。</p><ul><li>runningAsyncCalls</li></ul><p>异步请求队列，里面存储正在执行，包含已经取消但是还没有结束的请求。</p><ul><li>ExecutorService</li></ul><p>线程池，最小0，最大Max的线程池。</p><h2 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h2><h3 id="RetryAndFollowUpInterceptor"><a href="#RetryAndFollowUpInterceptor" class="headerlink" title="RetryAndFollowUpInterceptor"></a>RetryAndFollowUpInterceptor</h3><p>重试与重定向拦截器。</p><p>通过 while (true) 的死循环来进行对异常结果或者响应结果判断是否要进行重新请求。</p><h3 id="BirdgeInterceptor"><a href="#BirdgeInterceptor" class="headerlink" title="BirdgeInterceptor"></a>BirdgeInterceptor</h3><p>桥接拦截器。</p><p>为用户构建的一个 Request 请求转化为能够进行网络访问的请求，同时将网络请求回来的响应 Response 转化为用户可用的 Response。初始化信息，添加请求头等，比如涉及的网络文件的类型和网页的编码，返回的数据的解压处理等等。</p><h3 id="CacheInterceptor"><a href="#CacheInterceptor" class="headerlink" title="CacheInterceptor"></a>CacheInterceptor</h3><p>缓存拦截器。</p><p>根据 OkHttpClient 对象的配置以及缓存策略对请求值进行缓存。</p><p>内部有Cache类，处理缓存操作，intercache内部类，disklrucache算法等<br>重点是不缓存非get的请求。<br>CacheStrategy缓存策略类，通过工厂模式获取。</p><h3 id="ConnectionInterceptor"><a href="#ConnectionInterceptor" class="headerlink" title="ConnectionInterceptor"></a>ConnectionInterceptor</h3><p>网络连接拦截器。</p><p>底层是通过 SOCKET 的方式于服务端进行连接的，并且在连接建立之后会通过 OKIO 获取通向 server 端的输入流 Source 和输出流 Sink。</p><h3 id="CallServerInterceptor"><a href="#CallServerInterceptor" class="headerlink" title="CallServerInterceptor"></a>CallServerInterceptor</h3><p>服务请求的拦截器。</p><p>负责与服务器建立 Socket 连接，并且创建了一个 HttpStream 它包括通向服务器的输入流和输出流。</p><h3 id="自定义拦截器"><a href="#自定义拦截器" class="headerlink" title="自定义拦截器"></a>自定义拦截器</h3><h4 id="Application-Interceptor"><a href="#Application-Interceptor" class="headerlink" title="Application Interceptor"></a>Application Interceptor</h4><p>在 retryAndFollowUpInterceptor 之前，处于拦截器第一个位置。</p><p>它是第一个触发拦截的，这里拦截到的url请求的信息都是最原始的信息。所以我们可以在该拦截器中添加一些我们请求中需要的通用信息，打印一些我们需要的日志。可以定义多个这样的拦截器，例如一个处理 header 信息，一个处理 接口请求的 加解密 。</p><h4 id="NetwrokInterceptor"><a href="#NetwrokInterceptor" class="headerlink" title="NetwrokInterceptor"></a>NetwrokInterceptor</h4><p>在 ConnectInterceptor 和 CallServerInterceptor 之间，处于拦截器倒数第二个位置。</p><p>会经过 RetryAndFollowIntercptor 进行重定向并且也会通过 BridgeInterceptor 进行 request请求头和 响应 resposne 的处理，因此这里可以得到的是更多的信息。在打印结果可以看到它内部重定向操作和失败重试，这里会有比 Application Interceptor 更多的日志。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;OkHttp&quot;&gt;&lt;a href=&quot;#OkHttp&quot; class=&quot;headerlink&quot; title=&quot;OkHttp&quot;&gt;&lt;/a&gt;OkHttp&lt;/h1&gt;&lt;p&gt;是对 Socket 的封装。URLConnection 在4.4以后底层也使用了 OkHttp。&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>小计-第一次报告 Android 官方错误</title>
    <link href="https://codepoem.github.io/2021/06/10/%E5%B0%8F%E8%AE%B0-%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%8A%A5%E5%91%8A%20Android%20%E5%AE%98%E6%96%B9%E9%94%99%E8%AF%AF/"/>
    <id>https://codepoem.github.io/2021/06/10/小记-第一次报告 Android 官方错误/</id>
    <published>2021-06-10T14:43:00.000Z</published>
    <updated>2021-06-10T14:43:03.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近在阅读 Android 官方文档<a href="https://developer.android.com/jetpack/guide" target="_blank" rel="noopener">《应用架构指南》</a>一篇，在实操过程中发现示例代码的一处错误。</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p><a href="https://developer.android.com/jetpack/guide#connect-viewmodel-repository" target="_blank" rel="noopener">UserProfileViewModel</a> 的示例代码中</p><p>代码行：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> user = LiveData&lt;User&gt; = _user</span><br></pre></td></tr></table></figure><p>应该为：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> user :LiveData&lt;User&gt; = _user</span><br></pre></td></tr></table></figure><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>本次发现也已向 Google 提交了 <a href="https://issuetracker.google.com/issues/190329948" target="_blank" rel="noopener">issue</a>，并得到了反馈。</p><p>虽然只是一处简单的文档笔误，但是也见证了我仔细阅读文档并实操的过程。</p><hr><p>另外，这是我第一次对 Android 官方文档反馈问题，算是拿到“一血”，仅此记录一下~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;最近在阅读 Android 官方文档&lt;a href=&quot;https://developer.android.com/jetpack/guide
      
    
    </summary>
    
      <category term="Android" scheme="https://codepoem.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="https://codepoem.github.io/tags/Android/"/>
    
      <category term="小计" scheme="https://codepoem.github.io/tags/%E5%B0%8F%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>优雅Intent ActivityResult</title>
    <link href="https://codepoem.github.io/2020/12/13/%E4%BC%98%E9%9B%85Intent%20ActivityResult/"/>
    <id>https://codepoem.github.io/2020/12/13/优雅Intent ActivityResult/</id>
    <published>2020-12-13T12:49:21.000Z</published>
    <updated>2020-12-13T12:49:25.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ActivityResult-新时代"><a href="#ActivityResult-新时代" class="headerlink" title="ActivityResult 新时代"></a>ActivityResult 新时代</h2><p>跳转 Activity 获取返回值，我们怎么做?</p><p>AndroidX Activity 1.2.0-alpha02 和 Fragment 1.3.0-alpha02 是新旧时代的划分线。</p><p>调用方假设为 IntentsActivity，被调用方假设为 IntentResultActivity。</p><ul><li><p>旧石器时代：</p><p>调用方：</p><ol><li>调用 startActivityForResult 传入请求码，传输数据（可选）。</li><li>覆写 onActivityResult 方法，根据请求码和结果码获取返回结果信息。</li></ol><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IntentsConstants</span> </span>&#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">val</span> REQUEST_CODE_OLD = <span class="number">1</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">val</span> RESULT_CODE_OLD = <span class="number">100</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">val</span> EXTRA_RESULT_OLD_REQUEST = <span class="string">"extra_result_old_request"</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">val</span> EXTRA_RESULT_OLD_RESULT = <span class="string">"extra_result_old_result"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">start</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">val</span> intent = Intent(<span class="keyword">this</span><span class="symbol">@IntentsActivity</span>, IntentResultActivity::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>)</span></span><br><span class="line">  <span class="keyword">val</span> bundle = Bundle()</span><br><span class="line">  bundle.putString(EXTRA_RESULT_OLD_REQUEST, <span class="string">"OLD"</span>)</span><br><span class="line">  intent.putExtras(bundle)</span><br><span class="line">  startActivityForResult(</span><br><span class="line">      intent,</span><br><span class="line">      IntentsConstants.REQUEST_CODE_OLD</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onActivityResult</span><span class="params">(requestCode: <span class="type">Int</span>,   resultCode: <span class="type">Int</span>, <span class="keyword">data</span>: <span class="type">Intent</span>?)</span></span> &#123;</span><br><span class="line">  <span class="keyword">super</span>.onActivityResult(requestCode, resultCode, <span class="keyword">data</span>)</span><br><span class="line">  <span class="keyword">if</span> (requestCode == IntentsConstants.REQUEST_CODE_OLD &amp;&amp; resultCode == IntentsConstants.RESULT_CODE_OLD) &#123;</span><br><span class="line">      <span class="keyword">val</span> result = <span class="keyword">data</span>?.extras?.getString(IntentsConstants.EXTRA_RESULT_OLD_RESULT)</span><br><span class="line">      Toast.makeText(<span class="keyword">this</span><span class="symbol">@IntentsActivity</span>, <span class="string">"result: <span class="variable">$result</span>"</span>, Toast.LENGTH_SHORT).show()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>被调用方：</p><ol><li>finish 前 调用 setResult，传入结果码，返回数据（可选）。</li></ol><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onBackPressed</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> resultIntent = Intent()</span><br><span class="line">    <span class="keyword">val</span> resultBundle = Bundle()</span><br><span class="line">    resultBundle.putString(IntentsConstants.EXTRA_RESULT_OLD_RESULT, <span class="string">"resultold"</span>)</span><br><span class="line">    resultIntent.putExtras(resultBundle)</span><br><span class="line"></span><br><span class="line">    setResult(IntentsConstants.RESULT_CODE_OLD, resultIntent)</span><br><span class="line">    <span class="keyword">super</span>.onBackPressed()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>新石器时代</p><ol><li>引入依赖 AndroidX Activity 1.2.0-alpha02 和 Fragment 1.3.0-alpha02 或以上版本。</li><li>定义协议</li></ol><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">implementation <span class="string">'androidxactivity:activity-ktx:1.2.0-beta02'</span></span><br><span class="line">implementation <span class="string">'androidxfragment:fragment-ktx:1.3.0-beta02'</span></span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IntentResultContract</span> : <span class="type">ActivityResultContract</span>&lt;<span class="type">String, String</span>&gt;</span>() &#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">createIntent</span><span class="params">(context: <span class="type">Context</span>, input: <span class="type">String</span>?)</span></span>: Intent &#123;</span><br><span class="line">      <span class="keyword">return</span> Intent(context, IntentResultActivity::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>).<span class="title">apply</span> </span>&#123;</span><br><span class="line">          putExtras(Bundle().apply &#123;</span><br><span class="line">              putString(EXTRA_RESULT_NEW_REQUEST, <span class="string">"NEW"</span>)</span><br><span class="line">          &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">parseResult</span><span class="params">(resultCode: <span class="type">Int</span>, intent: <span class="type">Intent</span>?)</span></span>: String? &#123;</span><br><span class="line">      <span class="keyword">val</span> <span class="keyword">data</span> = intent?.extras?.getString(EXTRA_RESULT_NEW_RESULT)</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">if</span> (resultCode == RESULT_CODE_NEW &amp;&amp; <span class="keyword">data</span> != <span class="literal">null</span>) <span class="keyword">data</span></span><br><span class="line">      <span class="keyword">else</span> <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">val</span> RESULT_CODE_NEW = <span class="number">200</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">val</span> EXTRA_RESULT_NEW_REQUEST = <span class="string">"extra_result_new_request"</span></span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">val</span> EXTRA_RESULT_NEW_RESULT = <span class="string">"extra_result_new_result"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用方：</p><ol><li>注册协议</li><li>启动协议</li></ol><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> intentsActivityLauncher =</span><br><span class="line">registerForActivityResult(IntentResultContract()) &#123; result -&gt;</span><br><span class="line">    Toast.makeText(<span class="keyword">this</span><span class="symbol">@IntentsActivity</span>, <span class="string">"result: <span class="variable">$result</span>"</span>, Toast.LENGTH_SHORT).show()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">start</span><span class="params">()</span></span> &#123;</span><br><span class="line">  intentsActivityLauncher.launch(<span class="string">"NEW"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>被调用方：</p><ol><li>finish 前 调用 setResult，传入结果码，返回数据（可选）。</li></ol><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onBackPressed</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">val</span> resultIntent = Intent()</span><br><span class="line">  <span class="keyword">val</span> resultBundle = Bundle()</span><br><span class="line">  resultBundle.putString(IntentsConstants.EXTRA_RESULT_NEW_RESULT, <span class="string">"resultnew"</span>)</span><br><span class="line">  resultIntent.putExtras(resultBundle)</span><br><span class="line"></span><br><span class="line">  setResult(IntentsConstants.RESULT_CODE_NEW, resultIntent)</span><br><span class="line">  <span class="keyword">super</span>.onBackPressed()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h3><ul><li>ActivityResultContract：协议，定义了如何传递数据和如何处理返回的数据。</li><li>ActivityResultLauncher： 启动器，调用 ActivityResultLauncher 的 launch 方法来启动页面跳转，作用相当于原来的 startActivity()。</li></ul><h3 id="库中默认已实现-Contract"><a href="#库中默认已实现-Contract" class="headerlink" title="库中默认已实现 Contract"></a>库中默认已实现 Contract</h3><p>库中默认已实现的 Contract 都定义在 androidx.activity.result.contract.ActivityResultContracts 中。</p><ul><li><p>StartActivityForResult: 通用的 Contract，不做任何转换，Intent 作为输入，ActivityResult 作为输出，这也是最常用的一个协定。</p></li><li><p>RequestMultiplePermissions： 用于请求一组权限。</p></li><li><p>RequestPermission: 用于请求单个权限。</p></li><li><p>TakePicturePreview: 调用 MediaStore.ACTION_IMAGE_CAPTURE 拍照，返回值为 Bitmap 图片。</p></li><li><p>TakePicture: 调用 MediaStore.ACTION_IMAGE_CAPTURE 拍照，并将图片保存到给定的 Uri 地址，返回 true 表示保存成功。</p></li><li><p>TakeVideo: 调用 MediaStore.ACTION_VIDEO_CAPTURE 拍摄视频，保存到给定的 Uri 地址，返回一张缩略图。</p></li><li><p>PickContact: 从通讯录 APP 获取联系人。</p></li><li><p>GetContent: 提示用选择一条内容，返回一个通过 ContentResolver#openInputStream(Uri) 访问原生数据的 Uri 地址（content://形式） 。默认情况下，它增加了 Intent#CATEGORY_OPENABLE, 返回可以表示流的内容。</p></li><li><p>CreateDocument: 提示用户选择一个文档，返回一个(file:/http:/content:)开头的 Uri。</p></li><li><p>OpenMultipleDocuments: 提示用户选择文档（可以选择多个），分别返回它们的 Uri，以 List 的形式。</p></li><li><p>OpenDocumentTree: 提示用户选择一个目录，并返回用户选择的作为一个 Uri 返回，应用程序可以完全管理返回目录中的文档。</p></li></ul><h2 id="ActivityResult-新时代优势"><a href="#ActivityResult-新时代优势" class="headerlink" title="ActivityResult 新时代优势"></a>ActivityResult 新时代优势</h2><ol><li><p>以回调的方式获取返回值，而不是覆写方法。个人认为覆写方法获取返回值有一种“割裂”的感觉。</p></li><li><p>减少了样板代码，自定义 Contract 可以复用传值和解析值的逻辑。</p></li></ol><h2 id="Activity-销毁"><a href="#Activity-销毁" class="headerlink" title="Activity 销毁"></a>Activity 销毁</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;ActivityResult-新时代&quot;&gt;&lt;a href=&quot;#ActivityResult-新时代&quot; class=&quot;headerlink&quot; title=&quot;ActivityResult 新时代&quot;&gt;&lt;/a&gt;ActivityResult 新时代&lt;/h2&gt;&lt;p&gt;跳转 Act
      
    
    </summary>
    
      <category term="Android" scheme="https://codepoem.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="https://codepoem.github.io/tags/Android/"/>
    
      <category term="Intent" scheme="https://codepoem.github.io/tags/Intent/"/>
    
      <category term="ActivityResult" scheme="https://codepoem.github.io/tags/ActivityResult/"/>
    
  </entry>
  
  <entry>
    <title>译-viewlifecycleowner与this对比</title>
    <link href="https://codepoem.github.io/2020/11/24/%E8%AF%91-viewlifecycleowner%E4%B8%8Ethis%E5%AF%B9%E6%AF%94/"/>
    <id>https://codepoem.github.io/2020/11/24/译-viewlifecycleowner与this对比/</id>
    <published>2020-11-24T05:03:26.000Z</published>
    <updated>2020-11-24T05:03:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>哈喽，Android 小伙伴们~</p><p>这篇文章将提到 Fragment 中的两种 lifecycleowners。因为作为一个 Android 开发者，我们能够简单地使用 Fragment 作为 lifecycle owner，但某些情境下这可能会使你烦恼。</p><p>让我们先来看一下 Fragment 的生命周期：</p><center><p><img src="/assert/img/lifecycle/fragment_lifecycle.png" alt="FragmentLifecycle"></p></center><p>从图中我们可以看到 onCreate 和 onDestroy 只调用了一次。这些是 Fragment 的主要的生命周期方法。 onCreateView 和 onDestroyView 根据 Fragment 的状态来被调用，因为它们是 Fragment 中 View 的主要生命周期方法。</p><p>因此，如果我们在 onCreate 中绑定 LiveData ，仅仅注册一次似乎是很合适很健康的。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">liveData.observe(<span class="keyword">this</span>, observer)</span><br></pre></td></tr></table></figure><p>然而当我们跳转到另一个 Fragment 并且改变 LiveData 的值后再回到之前的 Fragment 时会发生什么呢?</p><p>返回到之前的 Fragment 时，我们不能获取到 LiveData 最新的数据，需要去请求它。</p><p>因此似乎使用 View 的 LifeCycle 方法是更有用的。在这种条件下，我们可能犯的一个共同的错误是使用 Fragment 作为 LifeCycle owner。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 onViewCreated, onCreateView, onActivityCreated 中调用</span></span><br><span class="line"><span class="comment">// 错误!!! 它可能造成重复观察或其他问题</span></span><br><span class="line">liveData.observe(<span class="keyword">this</span>, observer)</span><br></pre></td></tr></table></figure><p>我们应该使用 viewLifecycleOwner :</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 onViewCreated, onCreateView, onActivityCreated 中调用</span></span><br><span class="line">liveData.observe(viewLifecycleOwner, observer)</span><br></pre></td></tr></table></figure><hr><p><a href="https://medium.com/@cs.ibrahimyilmaz/viewlifecycleowner-vs-this-a8259800367b" target="_blank" rel="noopener">原文</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;哈喽，Android 小伙伴们~&lt;/p&gt;
&lt;p&gt;这篇文章将提到 Fragment 中的两种 lifecycleowners。因为作为一个 Android 开发者，我们能够简单地使用 Fragment 作为 lifecycle owner，但某些情境下这可能会使你烦恼。&lt;/p
      
    
    </summary>
    
      <category term="Android" scheme="https://codepoem.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="https://codepoem.github.io/tags/Android/"/>
    
      <category term="译文" scheme="https://codepoem.github.io/tags/%E8%AF%91%E6%96%87/"/>
    
      <category term="lifecycle" scheme="https://codepoem.github.io/tags/lifecycle/"/>
    
  </entry>
  
  <entry>
    <title>优雅FindViewById</title>
    <link href="https://codepoem.github.io/2020/04/18/%E4%BC%98%E9%9B%85FindViewById/"/>
    <id>https://codepoem.github.io/2020/04/18/优雅FindViewById/</id>
    <published>2020-04-18T05:06:23.000Z</published>
    <updated>2020-11-22T18:39:17.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="findBiewById"><a href="#findBiewById" class="headerlink" title="findBiewById"></a>findBiewById</h2><p>findBiewById 是 Android 开发中在布局中查找 View 元素的 Api。</p><h3 id="findBiewById-基本使用"><a href="#findBiewById-基本使用" class="headerlink" title="findBiewById 基本使用"></a>findBiewById 基本使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DemoActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">  TextView mTextDemo;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.activity_demo);</span><br><span class="line">    mTextDemo = (TextView) findViewById(R.id.tv_demo);</span><br><span class="line">    mTextDemo.setText(<span class="string">"Demo"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为写起来很繁琐（而且还需要手动强转类型），所以逐渐出现了各种简化或者代替它的方式。</p><h3 id="省略强转"><a href="#省略强转" class="headerlink" title="省略强转"></a>省略强转</h3><p>从 <a href="https://developer.android.google.cn/topic/libraries/support-library/rev-archive.html" target="_blank" rel="noopener">Android Support Library 26.0.0 Beta 1</a> 开始 findViewById 将不再需要强转了。</p><p>findViewById() 方法的所有实例现在会返回 &lt;T extends View&gt; T，而不是 View。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DemoActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">  TextView mTextDemo;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.activity_demo);</span><br><span class="line">    mTextDemo = findViewById(R.id.tv_demo);</span><br><span class="line">    mTextDemo.setText(<span class="string">"Demo"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="findBiewById-原理"><a href="#findBiewById-原理" class="headerlink" title="findBiewById 原理"></a>findBiewById 原理</h3><p>findBiewById 原理实质上是递归遍历查找匹配 Id 的 View。</p><p>Activity 中 findViewId 方法会调用获取 Window -&gt; DecoreView -&gt; View 的 findBiewById 方法。</p><p>最终会调用到 View 中的 findViewTraversal 方法。方法名看上去是遍历操作，在 View 类中找不到遍历逻辑；<br>实际上 ViewGroup 覆写了 View 的 findViewTraversal 方法，实现了递归遍历查找匹配 View 的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> &lt;T extends View&gt; <span class="function">T <span class="title">findViewById</span><span class="params">(@IdRes <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (id == NO_ID) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> findViewTraversal(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> &lt;T extends View&gt; <span class="function">T <span class="title">findViewTraversal</span><span class="params">(@IdRes <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (id == mID) &#123;</span><br><span class="line">            <span class="keyword">return</span> (T) <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewGroup</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * &#123;<span class="doctag">@hide</span>&#125;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">protected</span> &lt;T extends View&gt; <span class="function">T <span class="title">findViewTraversal</span><span class="params">(@IdRes <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (id == mID) &#123;</span><br><span class="line">            <span class="keyword">return</span> (T) <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> View[] where = mChildren;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> len = mChildrenCount;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            View v = where[i];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((v.mPrivateFlags &amp; PFLAG_IS_ROOT_NAMESPACE) == <span class="number">0</span>) &#123;</span><br><span class="line">                v = v.findViewById(id);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (v != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> (T) v;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ButterKnife"><a href="#ButterKnife" class="headerlink" title="ButterKnife"></a><a href="https://jakewharton.github.io/butterknife/" target="_blank" rel="noopener">ButterKnife</a></h2><p>ButterKnife 是 jakewharton 大神开源作品，用于替代 findViewById ，避免繁琐的写法。</p><h3 id="ButterKnife-基本使用"><a href="#ButterKnife-基本使用" class="headerlink" title="ButterKnife 基本使用"></a>ButterKnife 基本使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DemoActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">  <span class="meta">@BindView</span>(R.id.tv_demo)</span><br><span class="line">  TextView mTextDemo;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.activity_demo);</span><br><span class="line">    ButterKnife.bind(<span class="keyword">this</span>);</span><br><span class="line">    mTextDemo.setText(<span class="string">"Demo"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ButterKnife-原理"><a href="#ButterKnife-原理" class="headerlink" title="ButterKnife 原理"></a>ButterKnife 原理</h3><p>注解编译时生成绑定类，代替我们完成 FindViewById 的操作。</p><p>PS：ButterKnife Github ReadMe 中说明已不推荐使用，推荐下文提到的 Android 官方提供的 <a href="https://developer.android.com/topic/libraries/view-binding" target="_blank" rel="noopener">ViewBinding</a></p><h2 id="Data-Binding-Library"><a href="#Data-Binding-Library" class="headerlink" title="Data Binding Library"></a><a href="https://developer.android.google.cn/topic/libraries/data-binding/index.html" target="_blank" rel="noopener">Data Binding Library</a></h2><h3 id="Data-Binding-基本使用"><a href="#Data-Binding-基本使用" class="headerlink" title="Data Binding 基本使用"></a>Data Binding 基本使用</h3><p>布局需要使用 &lt;layout&gt; 标签包裹。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DemoActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.demo_activity);</span><br><span class="line">    ActivityDemoBinding binding = DataBindingUtil.setContentView(<span class="keyword">this</span>, R.layout.activity_demo);</span><br><span class="line">    binding.tvDemo.setText(<span class="string">"Demo"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Data-Binding-原理"><a href="#Data-Binding-原理" class="headerlink" title="Data Binding 原理"></a>Data Binding 原理</h3><p>自动查找所有 View 并缓存到 binding 实例中以供访问。性能超过手写的 findViewById，因为它只遍历了一遍 XML 布局，而 findViewById 每次都会去遍历 XML 布局；include 布局中的 view 也能同样能访问，并且保留结构。</p><h2 id="Kotlin-Android-Extensions"><a href="#Kotlin-Android-Extensions" class="headerlink" title="Kotlin Android Extensions"></a>Kotlin Android Extensions</h2><p>直接生成对应的 View 作为属性，不需要 findViewById，不需要定义变量，直接使用。使用时需要注意访问的 View 属于哪个 Layout，因为智能提示的候选项会提供所有布局中的 View 供你选择，然后帮你 import 对应包以便你访问这个 View；假如 import 的多个同一层级的 layout 中具有相同的 id，则这个 id 对应的 View 将无法访问。</p><h3 id="Kotlin-Android-Extensions-synthetic-基本使用"><a href="#Kotlin-Android-Extensions-synthetic-基本使用" class="headerlink" title="Kotlin Android Extensions synthetic 基本使用"></a>Kotlin Android Extensions synthetic 基本使用</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> kotlinx.android.synthetic.main.activity_demo.*</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DemoActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123; &#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span> <span class="keyword">public</span> void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.demo_activity);</span><br><span class="line">    tvDemo.setText(<span class="string">"Demo"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Kotlin-Android-Extensions-synthetic-原理"><a href="#Kotlin-Android-Extensions-synthetic-原理" class="headerlink" title="Kotlin Android Extensions synthetic 原理"></a>Kotlin Android Extensions synthetic 原理</h3><p>Kotlin 会自动生成类似 findViewById() 的方法：findCachedViewById()，在这个方法里面创建一个 HashMap 缓存每次查找到的 View，避免每次调用 View 的属性或方法时都会重新调用 findCachedViewById() 进行查找。</p><p>PS：在 <a href="https://github.com/JetBrains/kotlin/releases/tag/v1.4.20-M2" target="_blank" rel="noopener">Kotlin 1.4.20-M2</a> 中，JetBrain s废弃了 Kotlin Android Extensions 编译插件。推荐使用 ViewBinding。</p><h2 id="推荐使用-ViewBinding"><a href="#推荐使用-ViewBinding" class="headerlink" title="(推荐使用)ViewBinding"></a>(推荐使用)<a href="https://developer.android.com/topic/libraries/view-binding" target="_blank" rel="noopener">ViewBinding</a></h2><h3 id="ViewBinding-基本使用"><a href="#ViewBinding-基本使用" class="headerlink" title="ViewBinding 基本使用"></a>ViewBinding 基本使用</h3><p>Android Studio 3.6 Canary 11 及更高版本中可用。</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">  ...</span><br><span class="line">  viewBinding &#123;</span><br><span class="line">      enabled = <span class="keyword">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DemoActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123; &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> binding: ActivityDemoBinding</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span> <span class="keyword">public</span> void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    binding = ActivityDemoBinding.inflate(layoutInflater)</span><br><span class="line">    setContentView(binding.root)</span><br><span class="line">    binding.tvDemo.setText(<span class="string">"Demo"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ViewBinding-原理"><a href="#ViewBinding-原理" class="headerlink" title="ViewBinding 原理"></a>ViewBinding 原理</h3><h3 id="ViewBinding-优缺点"><a href="#ViewBinding-优缺点" class="headerlink" title="ViewBinding 优缺点"></a>ViewBinding 优缺点</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li><p>Null 安全：由于视图绑定会创建对视图的直接引用，因此不存在因视图 ID 无效而引发 Null 指针异常的风险。此外，如果视图仅出现在布局的某些配置中，则绑定类中包含其引用的字段会使用 @Nullable 标记。</p></li><li><p>类型安全：每个绑定类中的字段均具有与它们在 XML 文件中引用的视图相匹配的类型。这意味着不存在发生类转换异常的风险。</p></li><li><p>更快的编译速度：视图绑定不需要处理注释，因此编译时间更短。</p></li><li><p>易于使用：视图绑定不需要特别标记的 XML 布局文件，因此在应用中采用速度更快。在模块中启用视图绑定后，它会自动应用于该模块的所有布局。</p></li></ul><h4 id="缺点与限制"><a href="#缺点与限制" class="headerlink" title="缺点与限制"></a>缺点与限制</h4><ul><li>布局和代码之间的不兼容性可能会导致编译版本在编译时（而非运行时）失败。</li><li>视图绑定不支持布局变量或布局表达式，因此不能用于直接在 XML 布局文件中声明动态界面内容。</li><li>视图绑定不支持双向数据绑定。</li></ul><hr><p>相关文章</p><p><a href="https://juejin.im/post/5e69cb55e51d4526d87c8610#heading-4" target="_blank" rel="noopener">使用视图绑定替代 findViewById</a><br><a href="https://juejin.im/post/5dd407066fb9a020366f85fa#heading-5" target="_blank" rel="noopener">你好, View Binding! 再次再见, findViewById!</a><br><a href="https://juejin.im/entry/5d8caedd518825093a3579b0" target="_blank" rel="noopener">Kotlin 干掉了 findViewById，但用不好也会有性能问题</a><br><a href="https://proandroiddev.com/migrating-the-deprecated-kotlin-android-extensions-compiler-plugin-to-viewbinding-d234c691dec7" target="_blank" rel="noopener">Migrating the deprecated Kotlin Android Extensions compiler plugin</a><br><a href="https://blog.csdn.net/qq_17766199/article/details/109557820" target="_blank" rel="noopener">【译】迁移被废弃的Kotlin Android Extensions插件</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;findBiewById&quot;&gt;&lt;a href=&quot;#findBiewById&quot; class=&quot;headerlink&quot; title=&quot;findBiewById&quot;&gt;&lt;/a&gt;findBiewById&lt;/h2&gt;&lt;p&gt;findBiewById 是 Android 开发中在布局中
      
    
    </summary>
    
      <category term="Android" scheme="https://codepoem.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="https://codepoem.github.io/tags/Android/"/>
    
      <category term="FindViewById" scheme="https://codepoem.github.io/tags/FindViewById/"/>
    
  </entry>
  
  <entry>
    <title>万丈高楼平地起</title>
    <link href="https://codepoem.github.io/2020/03/19/Base/"/>
    <id>https://codepoem.github.io/2020/03/19/Base/</id>
    <published>2020-03-19T18:14:46.000Z</published>
    <updated>2020-03-21T13:20:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>重拾基础，备忘备战~</p><ul><li>算法总结-<a href="https://github.com/CodePoem/VAlgorithm" target="_blank" rel="noopener">VAlgorithm</a> -&gt; <a href="https://dreamcodepoem.xyz/VAlgorithm/#/" target="_blank" rel="noopener">LookUp</a></li><li>设计模式-<a href="https://github.com/CodePoem/VDesignPatterns" target="_blank" rel="noopener">VDesignPatterns</a> -&gt; <a href="https://dreamcodepoem.xyz/VDesignPatterns/#/" target="_blank" rel="noopener">LookUp</a></li><li>Android知识-<a href="https://github.com/CodePoem/VAndroidReview" target="_blank" rel="noopener">VAndroidReview</a> -&gt; <a href="https://dreamcodepoem.xyz/VAndroidReview/#/" target="_blank" rel="noopener">LookUp</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;重拾基础，备忘备战~&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;算法总结-&lt;a href=&quot;https://github.com/CodePoem/VAlgorithm&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;VAlgorithm&lt;/a&gt; -&amp;gt; &lt;a href
      
    
    </summary>
    
      <category term="万丈高楼平地起" scheme="https://codepoem.github.io/categories/%E4%B8%87%E4%B8%88%E9%AB%98%E6%A5%BC%E5%B9%B3%E5%9C%B0%E8%B5%B7/"/>
    
    
      <category term="Base" scheme="https://codepoem.github.io/tags/Base/"/>
    
      <category term="万丈高楼平地起" scheme="https://codepoem.github.io/tags/%E4%B8%87%E4%B8%88%E9%AB%98%E6%A5%BC%E5%B9%B3%E5%9C%B0%E8%B5%B7/"/>
    
  </entry>
  
  <entry>
    <title>Fragment可见性</title>
    <link href="https://codepoem.github.io/2020/03/05/Fragmnet%E5%8F%AF%E8%A7%81%E6%80%A7/"/>
    <id>https://codepoem.github.io/2020/03/05/Fragmnet可见性/</id>
    <published>2020-03-05T14:40:14.000Z</published>
    <updated>2020-05-27T15:17:32.000Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExampleFragment</span> <span class="keyword">extends</span> <span class="title">Fragment</span></span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 当fragment与viewpager、FragmentPagerAdapter一起使用时，切换页面时会调用此方法</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> isVisibleToUser 是否对用户可见</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserVisibleHint</span><span class="params">(<span class="keyword">boolean</span> isVisibleToUser)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">boolean</span> change = isVisibleToUser != getUserVisibleHint();</span><br><span class="line">            <span class="keyword">super</span>.setUserVisibleHint(isVisibleToUser);</span><br><span class="line">            <span class="comment">// 在viewpager中，创建fragment时就会调用这个方法，但这时还没有resume，为了避免重复调用visible和invisible，</span></span><br><span class="line">            <span class="comment">// 只有当fragment状态是resumed并且初始化完毕后才进行visible和invisible的回调</span></span><br><span class="line">            <span class="keyword">if</span> (isResumed() &amp;&amp; change) &#123;</span><br><span class="line">                <span class="keyword">if</span> (getUserVisibleHint()) &#123;</span><br><span class="line">                    onVisible();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    onInvisible();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 当使用show/hide方法时，会触发此回调</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> hidden fragment是否被隐藏</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onHiddenChanged</span><span class="params">(<span class="keyword">boolean</span> hidden)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.onHiddenChanged(hidden);</span><br><span class="line">            <span class="keyword">if</span> (hidden) &#123;</span><br><span class="line">                onInvisible();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                onVisible();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.onResume();</span><br><span class="line">            <span class="comment">// onResume并不代表fragment可见</span></span><br><span class="line">            <span class="comment">// 如果是在viewpager里，就需要判断getUserVisibleHint，不在viewpager时，getUserVisibleHint默认为true</span></span><br><span class="line">            <span class="comment">// 如果是其它情况，就通过isHidden判断，因为show/hide时会改变isHidden的状态</span></span><br><span class="line">            <span class="comment">// 所以，只有当fragment原来是可见状态时，进入onResume就回调onVisible</span></span><br><span class="line">            <span class="keyword">if</span> (getUserVisibleHint() &amp;&amp; !isHidden()) &#123;</span><br><span class="line">                onVisible();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPause</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.onPause();</span><br><span class="line">            <span class="comment">// onPause时也需要判断，如果当前fragment在viewpager中不可见，就已经回调过了，onPause时也就不需要再次回调onInvisible了</span></span><br><span class="line">            <span class="comment">// 所以，只有当fragment是可见状态时进入onPause才加调onInvisible</span></span><br><span class="line">            <span class="keyword">if</span> (getUserVisibleHint() &amp;&amp; !isHidden()) &#123;</span><br><span class="line">                onInvisible();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">onInvisible</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">onVisible</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            initData();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>补充 ：</p><p>setUserVisibleHint 为什么只在 Viewpager 有效？</p><p>实际上查看 setUserVisibleHint 的实际调用方，只有 FragmentPagerAdapter 和 FragmentStatePagerAdapter，也即 ViewPager 的适配器有调用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=
      
    
    </summary>
    
      <category term="Android" scheme="https://codepoem.github.io/categories/Android/"/>
    
    
      <category term="Fragment" scheme="https://codepoem.github.io/tags/Fragment/"/>
    
      <category term="可见性" scheme="https://codepoem.github.io/tags/%E5%8F%AF%E8%A7%81%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>ViewPager下Fragment预加载与懒加载</title>
    <link href="https://codepoem.github.io/2020/01/11/ViewPager%E4%B8%8BFragment%E9%A2%84%E5%8A%A0%E8%BD%BD%E4%B8%8E%E6%87%92%E5%8A%A0%E8%BD%BD/"/>
    <id>https://codepoem.github.io/2020/01/11/ViewPager下Fragment预加载与懒加载/</id>
    <published>2020-01-11T03:16:48.000Z</published>
    <updated>2020-01-11T03:16:52.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="预加载"><a href="#预加载" class="headerlink" title="预加载"></a>预加载</h2><p>ViewPager 控件有一个预加载机制，即默认情况下当前页面左右两侧的 1 个页面会被预加载，以方便用户滑动切换到相邻的界面时，更流畅地加载界面（节省了初始化时间）。</p><p>从源码里可以看到，ViewPager 的预加载机制是不可取消的，预加载数量 limit 至少为 1，如果外部设置小于 1，内部会自动置为 1。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewPager</span> <span class="keyword">extends</span> <span class="title">ViewGroup</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略其他代码</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOffscreenPageLimit</span><span class="params">(<span class="keyword">int</span> limit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (limit &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            Log.w(<span class="string">"ViewPager"</span>, <span class="string">"Requested offscreen page limit "</span> + limit + <span class="string">" too small; defaulting to "</span> + <span class="number">1</span>);</span><br><span class="line">            limit = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (limit != <span class="keyword">this</span>.mOffscreenPageLimit) &#123;</span><br><span class="line">            <span class="keyword">this</span>.mOffscreenPageLimit = limit;</span><br><span class="line">            <span class="keyword">this</span>.populate();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="懒加载"><a href="#懒加载" class="headerlink" title="懒加载"></a>懒加载</h2><p>在 ViewPager 预加载的机制下，ViewPager 本身比较难以实现 Fragment 实例化懒加载。既然 Fragment 的实例化难以懒加载，那么退而求其次，只要求实现 Fragment 请求数据的懒加载。</p><p>我们需要从 Fragment 本身入手。</p><p>主要用到 Fragment 两个方法：</p><ul><li>public void onViewCreated(View view, @Nullable Bundle savedInstanceState)</li><li>public void setUserVisibleHint(boolean isVisibleToUser)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseFragment</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">boolean</span> isViewCreated;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">boolean</span> isVisibleToUser;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">boolean</span> isDataInitiated;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onViewCreated</span><span class="params">(View view, @Nullable Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onViewCreated(view, savedInstanceState);</span><br><span class="line">        isViewCreated = <span class="keyword">true</span>;</span><br><span class="line">        lazyLoad();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserVisibleHint</span><span class="params">(<span class="keyword">boolean</span> isVisibleToUser)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.setUserVisibleHint(isVisibleToUser);</span><br><span class="line">        <span class="keyword">this</span>.isVisibleToUser = isVisibleToUser;</span><br><span class="line">        <span class="keyword">if</span> (isVisibleToUser) &#123;</span><br><span class="line">            lazyLoad();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">lazyLoad</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> lazyLoad(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">lazyLoad</span><span class="params">(<span class="keyword">boolean</span> forceRefresh)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isVisibleToUser &amp;&amp; isViewCreated &amp;&amp; (!isDataInitiated || forceRefresh)) &#123;</span><br><span class="line">            fetchData();</span><br><span class="line">            isDataInitiated = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">fetchData</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;预加载&quot;&gt;&lt;a href=&quot;#预加载&quot; class=&quot;headerlink&quot; title=&quot;预加载&quot;&gt;&lt;/a&gt;预加载&lt;/h2&gt;&lt;p&gt;ViewPager 控件有一个预加载机制，即默认情况下当前页面左右两侧的 1 个页面会被预加载，以方便用户滑动切换到相邻的界面时，更
      
    
    </summary>
    
      <category term="Android" scheme="https://codepoem.github.io/categories/Android/"/>
    
    
      <category term="Fragment" scheme="https://codepoem.github.io/tags/Fragment/"/>
    
      <category term="ViewPager" scheme="https://codepoem.github.io/tags/ViewPager/"/>
    
      <category term="预加载" scheme="https://codepoem.github.io/tags/%E9%A2%84%E5%8A%A0%E8%BD%BD/"/>
    
      <category term="懒加载" scheme="https://codepoem.github.io/tags/%E6%87%92%E5%8A%A0%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>设计模式总结</title>
    <link href="https://codepoem.github.io/2020/01/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/"/>
    <id>https://codepoem.github.io/2020/01/06/设计模式总结/</id>
    <published>2020-01-06T07:44:01.000Z</published>
    <updated>2020-01-06T07:44:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>阅读《大话设计模式》和《Android源码解析与实战》第2版时，进行的简单整理和总结，现已上传至Github上。</p><h2 id="Github"><a href="#Github" class="headerlink" title="Github"></a>Github</h2><ul><li><a href="https://github.com/CodePoem/VDesignPatterns" target="_blank" rel="noopener">Github 项目地址</a></li><li><a href="https://codepoem.github.io/VDesignPatterns">直接浏览地址</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;阅读《大话设计模式》和《Android源码解析与实战》第2版时，进行的简单整理和总结，现已上传至Github上。&lt;/p&gt;
&lt;h2 id=&quot;Github&quot;&gt;&lt;a href=&quot;#Github&quot; class=&quot;headerlink&quot; title=&quot;Github&quot;&gt;&lt;/a&gt;Gith
      
    
    </summary>
    
      <category term="设计模式" scheme="https://codepoem.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="https://codepoem.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="总结" scheme="https://codepoem.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>记录一次Android7.0适配FileProvider踩坑</title>
    <link href="https://codepoem.github.io/2019/11/16/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1Android7.0%E9%80%82%E9%85%8DFileProvider%E8%B8%A9%E5%9D%91/"/>
    <id>https://codepoem.github.io/2019/11/16/记录一次Android7.0适配FileProvider踩坑/</id>
    <published>2019-11-16T03:25:23.000Z</published>
    <updated>2019-11-16T03:25:27.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li>FileProvider重复</li></ul><p>自定义FileProvider继承FileProvider。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public class AppleFileProvider extends FileProvider &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AndroidManifest.xml中application节点下添加provider节点。</p><figure class="highlight plain"><figcaption><span>Provider</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;provider</span><br><span class="line">    android:name&#x3D;&quot;com.XXX.XXX.sample.AppleFileProvider&quot;</span><br><span class="line">    android:authorities&#x3D;&quot;$&#123;applicationId&#125;.file.provider&quot;</span><br><span class="line">    android:exported&#x3D;&quot;false&quot;</span><br><span class="line">    android:grantUriPermissions&#x3D;&quot;true&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;meta-data</span><br><span class="line">        android:name&#x3D;&quot;android.support.FILE_PROVIDER_PATHS&quot;</span><br><span class="line">        android:resource&#x3D;&quot;@xml&#x2F;apple_file_provider&quot;&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;provider&gt;</span><br></pre></td></tr></table></figure><ul><li>多个FileProvider authorities重复</li></ul><p>authorities一般是由包名+自定义的标识构成。</p><p>Uri uri = FileProvider.getUriForFile(getContext(), context.getPackageName() + “.file.provider”, file);</p><p>例子：</p><p>AppleFileProvider 和 BoyFileProvider 的authorities重复了，都为${applicationId}.file.provider。<br>默认会取apk中合并后的AndroidManifest.xml的第一个authorities匹配的FileProvider。</p><figure class="highlight plain"><figcaption><span>Provider</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;provider</span><br><span class="line">    android:name&#x3D;&quot;com.XXX.XXX.sample.AppleFileProvider&quot;</span><br><span class="line">    android:authorities&#x3D;&quot;$&#123;applicationId&#125;.file.provider&quot;</span><br><span class="line">    android:exported&#x3D;&quot;false&quot;</span><br><span class="line">    android:grantUriPermissions&#x3D;&quot;true&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;meta-data</span><br><span class="line">        android:name&#x3D;&quot;android.support.FILE_PROVIDER_PATHS&quot;</span><br><span class="line">        android:resource&#x3D;&quot;@xml&#x2F;apple_file_provider&quot;&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;provider&gt;</span><br><span class="line"></span><br><span class="line">&lt;provider</span><br><span class="line">    android:name&#x3D;&quot;com.XXX.XXX.sample.BoyFileProvider&quot;</span><br><span class="line">    android:authorities&#x3D;&quot;$&#123;applicationId&#125;.file.provider&quot;</span><br><span class="line">    android:exported&#x3D;&quot;false&quot;</span><br><span class="line">    android:grantUriPermissions&#x3D;&quot;true&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;meta-data</span><br><span class="line">        android:name&#x3D;&quot;android.support.FILE_PROVIDER_PATHS&quot;</span><br><span class="line">        android:resource&#x3D;&quot;@xml&#x2F;boy_file_provider&quot;&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;provider&gt;</span><br></pre></td></tr></table></figure><p>此时Uri uri = FileProvider.getUriForFile(getContext(), context.getPackageName() + “.file.provider”, file);会与AppleFileProvider匹配，也就会去取apple_file_provider.xml中的配置。<br>如果AppleFileProvider与BoyFileProvider在AndroidManifest的顺序互换一下，那么就会与BoyFileProvider匹配，也就会去取boy_file_provider.xml中的配置。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;FileProvider重复&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;自定义FileProvider继承FileProvider。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;
      
    
    </summary>
    
      <category term="Android" scheme="https://codepoem.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="https://codepoem.github.io/tags/Android/"/>
    
      <category term="FileProvider" scheme="https://codepoem.github.io/tags/FileProvider/"/>
    
  </entry>
  
  <entry>
    <title>简析Bitmap</title>
    <link href="https://codepoem.github.io/2019/10/16/%E7%AE%80%E6%9E%90Bitmap/"/>
    <id>https://codepoem.github.io/2019/10/16/简析Bitmap/</id>
    <published>2019-10-16T03:25:23.000Z</published>
    <updated>2019-10-16T03:25:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>基于9.0（29）简析Bitmap类。</p><p>我们只关注Bitmap类暴露出来的（即访问权限为public）东西。</p><ul><li>枚举类Config</li><li>枚举类CompressFormat</li><li>若干 createBitmap 静态方法</li><li>其他方法</li></ul><h2 id="枚举类Config"><a href="#枚举类Config" class="headerlink" title="枚举类Config"></a>枚举类Config</h2><p>可能的 bitmap 配置。bitmap 配置描述像素的存储方式。这会影响质量（颜色深度）以及显示透明/半透明颜色的能力。</p><table><thead><tr><th>Config</th><th>每个像素占用字节数</th><th>表示颜色种数</th><th>说明</th></tr></thead><tbody><tr><td>ALPHA_8</td><td>1个字节，A分量占8位，不存储颜色信息</td><td>0</td><td>单透明通道</td></tr><tr><td>RGB_565</td><td>两个字节，R分量占5位，G分量占6位，B分量占5位</td><td>2^16(65536)</td><td>简易RGB色调</td></tr><tr><td>RGB_888</td><td>三个字节，R、G、B分量各占8位</td><td>2^24(16777216)</td><td>RGB色调</td></tr><tr><td>ARGB_4444</td><td>两个字节，A、R、G、B分量各占4位</td><td>2^12(4096)</td><td>已弃用，成像效果比较差，并且v4.4+后如果使用了它会自动转成用ARGB_8888。</td></tr><tr><td>ARGB_8888</td><td>四个字节，A、R、G、B分量各占8位</td><td>2^24(16777216)</td><td>24位真彩色，Android中默认的配置</td></tr><tr><td>RGBA_F16</td><td>八个字节，A、R、G、B分量各占16位</td><td>2^48(281474976710656)</td><td>特别适合于宽色域和HDR内容，在8.0（api 26）引入。</td></tr><tr><td>HARDWARE</td><td>-</td><td>-</td><td>特殊配置。bitmap始终存储在图形内存中，在8.0（api 26）引入。</td></tr></tbody></table><h2 id="枚举类CompressFormat"><a href="#枚举类CompressFormat" class="headerlink" title="枚举类CompressFormat"></a>枚举类CompressFormat</h2><p>指定可以将 bitmap 压缩为的已知格式。</p><ul><li>JPEG</li><li>PNG</li><li>WEBP</li></ul><h2 id="若干-createBitmap-静态方法"><a href="#若干-createBitmap-静态方法" class="headerlink" title="若干 createBitmap 静态方法"></a>若干 createBitmap 静态方法</h2><h3 id="public-static-Bitmap-wrapHardwareBuffer-NonNull-HardwareBuffer-hardwareBuffer-Nullable-ColorSpace-colorSpace"><a href="#public-static-Bitmap-wrapHardwareBuffer-NonNull-HardwareBuffer-hardwareBuffer-Nullable-ColorSpace-colorSpace" class="headerlink" title="public static Bitmap wrapHardwareBuffer(@NonNull HardwareBuffer hardwareBuffer, @Nullable ColorSpace colorSpace)"></a>public static Bitmap wrapHardwareBuffer(@NonNull HardwareBuffer hardwareBuffer, @Nullable ColorSpace colorSpace)</h3><p>创建由 HardwareBuffer 支持的硬件位图。</p><p>传递的 HardwareBuffer 使用标志必须包含 HardwareBuffer.USAGE_GPU_SAMPLED_IMAGE。</p><p>bitmap 将保留对缓冲区的引用，以便调用者可以安全地关闭 HardwareBuffer 而不会影响 bitmap 。但是，在包装 bitmap 访问硬件缓冲区时，不能对其进行修改。这样做将导致不确定的行为。</p><ul><li>HardwareBuffer hardwareBuffer：包装的 HardwareBuffer。</li><li>ColorSpace colorSpace：bitmap 的颜色空间。必须是 ColorSpace.Rgb 颜色空间。如果为 null ，则假定为SRGB。</li></ul><h3 id="public-static-Bitmap-createScaledBitmap-NonNull-Bitmap-src-int-dstWidth-int-dstHeight-boolean-filter"><a href="#public-static-Bitmap-createScaledBitmap-NonNull-Bitmap-src-int-dstWidth-int-dstHeight-boolean-filter" class="headerlink" title="public static Bitmap createScaledBitmap(@NonNull Bitmap src, int dstWidth, int dstHeight, boolean filter)"></a>public static Bitmap createScaledBitmap(@NonNull Bitmap src, int dstWidth, int dstHeight, boolean filter)</h3><p>如果可能，创建一个新的 bitmap ，从现有的 bitmap 缩放。如果指定的宽度和高度与源位图的当前宽度和高度相同，则返回源位图，并且不创建新的位图。</p><ul><li>Bitmap src：源 bitmap。</li><li>int dstWidth：新 bitmap 的所需宽度</li><li>int dstHeight：新 bitmap 的所需高度</li><li>boolean filter：缩放 bitmap 时是否使用双线性滤波。如果为 true ，则在缩放时将使用双线性滤波，从而以较差的性能为代价来获得更好的图像质量。如果为 false ，则使用邻近采样缩放，这将使图像质量较差，但速度更快。推荐的默认值是将设置为 true，因为双线性滤镜的成本通常很小，并且改善的图像质量非常重要。</li></ul><h3 id="public-static-Bitmap-createBitmap-NonNull-Bitmap-src"><a href="#public-static-Bitmap-createBitmap-NonNull-Bitmap-src" class="headerlink" title="public static Bitmap createBitmap(@NonNull Bitmap src)"></a>public static Bitmap createBitmap(@NonNull Bitmap src)</h3><p>重载 Bitmap createBitmap(@NonNull Bitmap source, int x, int y, int width, int height)</p><p>createBitmap(src, 0, 0, src.getWidth(), src.getHeight());</p><h3 id="public-static-Bitmap-createBitmap-NonNull-Bitmap-source-int-x-int-y-int-width-int-height"><a href="#public-static-Bitmap-createBitmap-NonNull-Bitmap-source-int-x-int-y-int-width-int-height" class="headerlink" title="public static Bitmap createBitmap(@NonNull Bitmap source, int x, int y, int width, int height)"></a>public static Bitmap createBitmap(@NonNull Bitmap source, int x, int y, int width, int height)</h3><p>重载 Bitmap createBitmap(@NonNull Bitmap source, int x, int y, int width, int height, @Nullable Matrix m, boolean filter)</p><p>createBitmap(source, x, y, width, height, null, false);</p><h3 id="public-static-Bitmap-createBitmap-NonNull-Bitmap-source-int-x-int-y-int-width-int-height-Nullable-Matrix-m-boolean-filter"><a href="#public-static-Bitmap-createBitmap-NonNull-Bitmap-source-int-x-int-y-int-width-int-height-Nullable-Matrix-m-boolean-filter" class="headerlink" title="public static Bitmap createBitmap(@NonNull Bitmap source, int x, int y, int width, int height, @Nullable Matrix m, boolean filter)"></a>public static Bitmap createBitmap(@NonNull Bitmap source, int x, int y, int width, int height, @Nullable Matrix m, boolean filter)</h3><p>从源 bitmap 返回一个 bitmap 。新的bitmap 可能与源 bitmap 是同一对象，或者可能已复制。使用与源 bitmap 相同的密度和色彩空间进行初始化。</p><p>如果源 bitmap 是不可变的，并且所请求的子集与源 bitmsp 本身相同，则返回源 bitmap ，并且不会创建新 bitmap 。</p><p>除非在以下情况下，否则返回的 bitmap 将始终是可变的：<br>（1）在返回源 bitmap 且源 bitmap 不可变的情况下<br>（2）源 bitmap 是硬件 bitmap 。即 getConfig() = Config.HARDWARE 。</p><ul><li>Bitmap source：源 bitmap 。</li><li>int x：源中第一个像素的x坐标</li><li>int y：源中第一个像素的y坐标</li><li>int width：每行像素数</li><li>int height：行数</li><li>Matrix m：应用于像素的可选矩阵</li><li>boolean filter：是否使用双线性滤波，则为true。仅在矩阵包含的不仅仅是平移时适用。</li></ul><h3 id="public-static-Bitmap-createBitmap-int-width-int-height-NonNull-Config-config"><a href="#public-static-Bitmap-createBitmap-int-width-int-height-NonNull-Config-config" class="headerlink" title="public static Bitmap createBitmap(int width, int height, @NonNull Config config)"></a>public static Bitmap createBitmap(int width, int height, @NonNull Config config)</h3><p>重载 Bitmap createBitmap(int width, int height, @NonNull Config config, boolean hasAlpha)</p><p>createBitmap(null, width, height, config, hasAlpha)</p><h3 id="public-static-Bitmap-createBitmap-Nullable-DisplayMetrics-display-int-width-int-height-NonNull-Config-config"><a href="#public-static-Bitmap-createBitmap-Nullable-DisplayMetrics-display-int-width-int-height-NonNull-Config-config" class="headerlink" title="public static Bitmap createBitmap(@Nullable DisplayMetrics display, int width, int height, @NonNull Config config)"></a>public static Bitmap createBitmap(@Nullable DisplayMetrics display, int width, int height, @NonNull Config config)</h3><p>重载 Bitmap createBitmap(@Nullable DisplayMetrics display, int width, int height, @NonNull Config config, boolean hasAlpha)</p><p>createBitmap(display, width, height, config, true);</p><h3 id="public-static-Bitmap-createBitmap-int-width-int-height-NonNull-Config-config-boolean-hasAlpha"><a href="#public-static-Bitmap-createBitmap-int-width-int-height-NonNull-Config-config-boolean-hasAlpha" class="headerlink" title="public static Bitmap createBitmap(int width, int height, @NonNull Config config, boolean hasAlpha)"></a>public static Bitmap createBitmap(int width, int height, @NonNull Config config, boolean hasAlpha)</h3><p>重载 Bitmap createBitmap(@Nullable DisplayMetrics display, int width, int height, @NonNull Config config, boolean hasAlpha)</p><p>createBitmap(null, width, height, config, hasAlpha);</p><h3 id="public-static-Bitmap-createBitmap-int-width-int-height-NonNull-Config-config-boolean-hasAlpha-NonNull-ColorSpace-colorSpace"><a href="#public-static-Bitmap-createBitmap-int-width-int-height-NonNull-Config-config-boolean-hasAlpha-NonNull-ColorSpace-colorSpace" class="headerlink" title="public static Bitmap createBitmap(int width, int height, @NonNull Config config, boolean hasAlpha, @NonNull ColorSpace colorSpace)"></a>public static Bitmap createBitmap(int width, int height, @NonNull Config config, boolean hasAlpha, @NonNull ColorSpace colorSpace)</h3><p>重载 Bitmap createBitmap(@Nullable DisplayMetrics display, int width, int height, @NonNull Config config, boolean hasAlpha, @NonNull ColorSpace colorSpace)</p><p>createBitmap(null, width, height, config, hasAlpha, colorSpace);</p><h3 id="public-static-Bitmap-createBitmap-Nullable-DisplayMetrics-display-int-width-int-height-NonNull-Config-config-boolean-hasAlpha"><a href="#public-static-Bitmap-createBitmap-Nullable-DisplayMetrics-display-int-width-int-height-NonNull-Config-config-boolean-hasAlpha" class="headerlink" title="public static Bitmap createBitmap(@Nullable DisplayMetrics display, int width, int height, @NonNull Config config, boolean hasAlpha)"></a>public static Bitmap createBitmap(@Nullable DisplayMetrics display, int width, int height, @NonNull Config config, boolean hasAlpha)</h3><p>重载 Bitmap createBitmap(@Nullable DisplayMetrics display, int width, int height, @NonNull Config config, boolean hasAlpha, @NonNull ColorSpace colorSpace)</p><p>createBitmap(display, width, height, config, hasAlpha, ColorSpace.get(ColorSpace.Named.SRGB));</p><h3 id="public-static-Bitmap-createBitmap-Nullable-DisplayMetrics-display-int-width-int-height-NonNull-Config-config-boolean-hasAlpha-NonNull-ColorSpace-colorSpace"><a href="#public-static-Bitmap-createBitmap-Nullable-DisplayMetrics-display-int-width-int-height-NonNull-Config-config-boolean-hasAlpha-NonNull-ColorSpace-colorSpace" class="headerlink" title="public static Bitmap createBitmap(@Nullable DisplayMetrics display, int width, int height, @NonNull Config config, boolean hasAlpha, @NonNull ColorSpace colorSpace)"></a>public static Bitmap createBitmap(@Nullable DisplayMetrics display, int width, int height, @NonNull Config config, boolean hasAlpha, @NonNull ColorSpace colorSpace)</h3><p>返回具有指定宽度和高度的可变 bitmap。它的初始密度由给定的 DisplayMetrics 确定。新创建的 bitmap 位于 ColorSpace.Named.SRGB 颜色空间中。</p><ul><li>DisplayMetrics display：将被绘制的 bitmap 的显示的显示度量。</li><li>int width：bitmap 的宽度。</li><li>int height：bitmap 的高度。</li><li>Config config：创建的 bitmap 的配置。</li><li>boolean hasAlpha：如果 bitmap 是 ARGB_8888 或 RGBA_16F ，则此标志可用于将 bitmap 标记为不透明。这样做将以黑色而不是透明的方式清除 bitmap。</li><li>ColorSpace colorSpace：bitmap的颜色空间。如果配置为 Config.RGBA_F16 和 ColorSpace.Named.SRGB sRGB 或ColorSpace.Named.LINEAR_SRGB ，则假定为相应的扩展范围变体。</li></ul><h3 id="public-static-Bitmap-createBitmap-NonNull-ColorInt-int-colors-int-offset-int-stride-int-width-int-height-NonNull-Config-config"><a href="#public-static-Bitmap-createBitmap-NonNull-ColorInt-int-colors-int-offset-int-stride-int-width-int-height-NonNull-Config-config" class="headerlink" title="public static Bitmap createBitmap(@NonNull @ColorInt int[] colors, int offset, int stride, int width, int height, @NonNull Config config)"></a>public static Bitmap createBitmap(@NonNull @ColorInt int[] colors, int offset, int stride, int width, int height, @NonNull Config config)</h3><p>重载 Bitmap createBitmap(@NonNull DisplayMetrics display, @NonNull @ColorInt int[] colors, int offset, int stride, int width, int height, @NonNull Config config)</p><p>createBitmap(null, colors, offset, stride, width, height, config)</p><h3 id="public-static-Bitmap-createBitmap-NonNull-DisplayMetrics-display-NonNull-ColorInt-int-colors-int-offset-int-stride-int-width-int-height-NonNull-Config-config"><a href="#public-static-Bitmap-createBitmap-NonNull-DisplayMetrics-display-NonNull-ColorInt-int-colors-int-offset-int-stride-int-width-int-height-NonNull-Config-config" class="headerlink" title="public static Bitmap createBitmap(@NonNull DisplayMetrics display, @NonNull @ColorInt int[] colors, int offset, int stride, int width, int height, @NonNull Config config)"></a>public static Bitmap createBitmap(@NonNull DisplayMetrics display, @NonNull @ColorInt int[] colors, int offset, int stride, int width, int height, @NonNull Config config)</h3><p>返回具有指定宽度和高度的不可变 bitmap，每个像素值设置为 colors 数组中的相应值。它的初始密度由给定的 DisplayMetrics 确定。新创建的 bitmap 位于 ColorSpace.Named.SRGB 颜色空间中。</p><ul><li>DisplayMetrics display：将被绘制的 bitmap 的显示的显示度量。</li><li>@ColorInt int[] colors：sRGB Color数组，用于初始化像素。</li><li>int offset：颜色数组中第一个颜色之前要跳过的值数。</li><li>int stride：行之间数组中的颜色数（必须为 &gt;= width 或 &lt;= -width）。</li><li>int width：bitmap 的宽度。</li><li>int height：bitmap 的高度。</li><li>Config config：创建的 bitmap 的配置。如果配置不支持每像素的alpha（例如RGB_565），那么colors []中的alpha 字节将被忽略（假定为FF）</li></ul><h3 id="public-static-Bitmap-createBitmap-NonNull-ColorInt-int-colors-int-width-int-height-Config-config"><a href="#public-static-Bitmap-createBitmap-NonNull-ColorInt-int-colors-int-width-int-height-Config-config" class="headerlink" title="public static Bitmap createBitmap(@NonNull @ColorInt int[] colors, int width, int height, Config config)"></a>public static Bitmap createBitmap(@NonNull @ColorInt int[] colors, int width, int height, Config config)</h3><p>重载 Bitmap createBitmap(@NonNull DisplayMetrics display, @NonNull @ColorInt int[] colors, int offset, int stride, int width, int height, @NonNull Config config)</p><p>createBitmap(null, colors, 0, width, width, height, config);</p><h3 id="public-static-Bitmap-createBitmap-Nullable-DisplayMetrics-display-NonNull-ColorInt-int-colors-int-width-int-height-NonNull-Config-config"><a href="#public-static-Bitmap-createBitmap-Nullable-DisplayMetrics-display-NonNull-ColorInt-int-colors-int-width-int-height-NonNull-Config-config" class="headerlink" title="public static Bitmap createBitmap(@Nullable DisplayMetrics display, @NonNull @ColorInt int colors[], int width, int height, @NonNull Config config)"></a>public static Bitmap createBitmap(@Nullable DisplayMetrics display, @NonNull @ColorInt int colors[], int width, int height, @NonNull Config config)</h3><p>重载 Bitmap createBitmap(@NonNull DisplayMetrics display, @NonNull @ColorInt int[] colors, int offset, int stride, int width, int height, @NonNull Config config)</p><p>createBitmap(display, colors, 0, width, width, height, config);</p><h3 id="public-static-NonNull-Bitmap-createBitmap-NonNull-Picture-source"><a href="#public-static-NonNull-Bitmap-createBitmap-NonNull-Picture-source" class="headerlink" title="public static @NonNull Bitmap createBitmap(@NonNull Picture source)"></a>public static @NonNull Bitmap createBitmap(@NonNull Picture source)</h3><p>重载 Bitmap createBitmap(@NonNull Picture source, int width, int height, @NonNull Config config)</p><p>createBitmap(source, source.getWidth(), source.getHeight(), Config.HARDWARE);</p><h3 id="public-static-NonNull-Bitmap-createBitmap-NonNull-Picture-source-int-width-int-height-NonNull-Config-config"><a href="#public-static-NonNull-Bitmap-createBitmap-NonNull-Picture-source-int-width-int-height-NonNull-Config-config" class="headerlink" title="public static @NonNull Bitmap createBitmap(@NonNull Picture source, int width, int height, @NonNull Config config)"></a>public static @NonNull Bitmap createBitmap(@NonNull Picture source, int width, int height, @NonNull Config config)</h3><p>从记录的绘图命令中给定 Picture 源创建 bitmap。</p><p>在给定的宽度和高度下，bitmap 将不可变。如果宽度和高度与图片的宽度和高度不同，则图片将缩放以适应给定的宽度和高度。</p><ul><li>Picture source：记录的绘图命令 Picture 将会被绘制到返回的 bitmap 中</li><li>int width：要创建的 bitmap 的宽度。图片的宽度将根据需要缩放以匹配。</li><li>int height：要创建的 bitmap 的高度。图片的高度将根据需要缩放以匹配。</li><li>Config config：创建的 bitmap 的配置。</li></ul><h2 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h2><h3 id="int-getDensity"><a href="#int-getDensity" class="headerlink" title="int getDensity()"></a>int getDensity()</h3><p>返回此 bitmap 的密度。</p><p>默认密度与当前显示的密度相同，除非当前应用程序不支持不同的屏幕密度，这种情况下默认密度为 android.util.DisplayMetric.DENSITY_DEFAULT = DENSITY_MEDIUM = 160。请注意，兼容性模式由最初加载到进程中的应用程序确定-共享同一进程的应用程序应该全部具有相同的兼容性，或者确保它们适当地显式设置其 bitmap 的密度。</p><h3 id="void-setDensity-int-density"><a href="#void-setDensity-int-density" class="headerlink" title="void setDensity(int density)"></a>void setDensity(int density)</h3><p>指定此 bitmap 的密度。当 bitmap 绘制到也具有密度的Canvas时，它将适当缩放。</p><ul><li>int densit：该 bitmap 使用的密度缩放因子；如果密度未知，则使用DENSITY_NONE = 0。</li></ul><h3 id="void-reconfigure-int-width-int-height-Config-config"><a href="#void-reconfigure-int-width-int-height-Config-config" class="headerlink" title="void reconfigure(int width, int height, Config config)"></a>void reconfigure(int width, int height, Config config)</h3><p>将 bitmap 修改为具有指定的宽度，高度和 Config ，而不影响该 bitmap 的底层分配。 对于新配置，bitmap 像素数据未重新初始化。</p><p>此方法可用于避免分配新的 bitmap，而是将现有 bitmap 的分配重用于大小等于或小于的新配置。如果 bitmap 的分配不足以支持新配置，则将抛出IllegalArgumentException，并且 bitmap 将不会被修改。</p><p>getByteCount（）的结果将反映新的配置，而getAllocationByteCount（）的结果将反映初始的配置。</p><p>注意：这可能会更改hasAlpha（）的结果。当转换为565时，新的 bitmap 将始终被视为不透明的。从565转换时，新的 bitmap 将被认为是不透明的，并且将遵循由setPremultiplied（）设置的值。</p><p>警告：不应在当前正在 view 系统、Canvas 或 AndroidBitmap NDK API 使用的 bitmap 上调用此方法。它不能保证基础像素缓冲区如何重新映射到新配置，而只是保证分配已被重用。此外，view 系统无法确定使用过程中正在修改的 bitmap 属性，例如何时附着在 drawables 上。</p><p>为了安全地确保 view 系统不再使用 bitmap，必须等待正在invalidate（）的任何在最后的绘制过程中由于硬件加速对绘制命令的缓存已经在之前绘制过此 bitmap 的 view 完成绘制过程。举一个例子，以下是以 ImageView 完成的：</p><figure class="highlight plain"><figcaption><span>bitmap reconfigure</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ImageView myImageView &#x3D; ...;</span><br><span class="line">final Bitmap myBitmap &#x3D; ...;</span><br><span class="line">myImageView.setImageDrawable(null);</span><br><span class="line">myImageView.post(new Runnable() &#123;</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        &#x2F;&#x2F; myBitmap is now no longer in use by the ImageView</span><br><span class="line">        &#x2F;&#x2F; and can be safely reconfigured.</span><br><span class="line">        myBitmap.reconfigure(...);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="void-setWidth-int-width"><a href="#void-setWidth-int-width" class="headerlink" title="void setWidth(int width)"></a>void setWidth(int width)</h3><p>使用当前已有高度和配置调用 reconfigure（int，int，Config）的便捷方法。</p><p>警告：此方法不应在 view 系统当前使用的 bitmap 上使用，有关更多详细信息，请参见 reconfigure（int，int，Config）。</p><h3 id="void-setHeight-int-height"><a href="#void-setHeight-int-height" class="headerlink" title="void setHeight(int height)"></a>void setHeight(int height)</h3><p>使用当前已有宽度和配置调用 reconfigure（int，int，Config）的便捷方法。</p><p>警告：此方法不应在 view 系统当前使用的 bitmap 上使用，有关更多详细信息，请参见 reconfigure（int，int，Config）。</p><h3 id="void-setConfig-Config-config"><a href="#void-setConfig-Config-config" class="headerlink" title="void setConfig(Config config)"></a>void setConfig(Config config)</h3><p>使用当前已有宽度和高度调用 reconfigure（int，int，Config）的便捷方法。</p><p>警告：此方法不应在 view 系统当前使用的 bitmap 上使用，有关更多详细信息，请参见 reconfigure（int，int，Config）。</p><h3 id="void-setNinePatchChunk-byte-chunk"><a href="#void-setNinePatchChunk-byte-chunk" class="headerlink" title="void setNinePatchChunk(byte[] chunk)"></a>void setNinePatchChunk(byte[] chunk)</h3><p>设置.9图数据块。</p><ul><li>byte[] chunk .9图相关定义数据块</li></ul><h3 id="void-recycle"><a href="#void-recycle" class="headerlink" title="void recycle()"></a>void recycle()</h3><p>释放与此 bitmap 关联的 native 对象，并清除对像素数据的引用。这将不会同步释放像素数据。 如果没有其他引用，它只是允许对其进行垃圾回收。bitmap 被标记为“死亡”，这意味着如果 getPixels（）或setPixels（）被调用，它将抛出异常，并且不会绘制任何内容。 此操作不能撤消，因此只有在确定 bitmap 没有进一步用途时才应调用它。这是一个高级调用，通常不需要，因为当没有更多对该 bitmap 的引用时，正常的GC进程将释放此内存。</p><h3 id="boolean-isRecycled"><a href="#boolean-isRecycled" class="headerlink" title="boolean isRecycled()"></a>boolean isRecycled()</h3><p>如果此 bitmap 已被回收，则返回true。如果是被回收，则尝试访问其像素是一个错误，并且 bitmap 将不会绘制。</p><h3 id="int-getGenerationId"><a href="#int-getGenerationId" class="headerlink" title="int getGenerationId()"></a>int getGenerationId()</h3><p>返回此 bitmap 的生成ID。只要修改 bitmap，生成ID就会改变。这是一个可用于检查 bitmap 是否已更改的高效方法。</p><h3 id="void-copyPixelsToBuffer-Buffer-dst"><a href="#void-copyPixelsToBuffer-Buffer-dst" class="headerlink" title="void copyPixelsToBuffer(Buffer dst)"></a>void copyPixelsToBuffer(Buffer dst)</h3><p>将 bitmap 的像素复制到指定的缓冲区（由调用者分配）。如果缓冲区的大小不足以容纳所有像素（考虑到每个像素的字节数），或者如果Buffer子类不是支持类型之一（ByteBuffer，ShortBuffer，IntBuffer），则抛出异常。</p><p>bitmap 的内容按原样复制到缓冲区中。这意味着如果该 bitmap 存储了预乘的像素（请参见 isPremultiplied()），则缓冲区中的值也将被预乘。像素保留在 bitmap 的颜色空间中）。</p><p>返回此方法后，将更新缓冲区的当前位置：位置将增加写入缓冲区的元素数量。</p><h3 id="void-copyPixelsFromBuffer-Buffer-src"><a href="#void-copyPixelsFromBuffer-Buffer-src" class="headerlink" title="void copyPixelsFromBuffer(Buffer src)"></a>void copyPixelsFromBuffer(Buffer src)</h3><p>从当前位置开始，从缓冲区复制像素，覆盖 bitmap 的像素。缓冲区中的数据不会以任何方式更改（不同于setPixels（），后者会从未预乘的32bit转换为 bitmap 的 native 格式。源缓冲区中的像素假定位于 bitmap 的色彩空间中）。</p><p>返回此方法后，将更新缓冲区的当前位置：该位置将增加从缓冲区读取的元素数。如果需要再次从缓冲区读取 bitmap，则必须首先倒带缓冲区。</p><h3 id="Bitmap-copy-Config-config-boolean-isMutable"><a href="#Bitmap-copy-Config-config-boolean-isMutable" class="headerlink" title="Bitmap copy(Config config, boolean isMutable)"></a>Bitmap copy(Config config, boolean isMutable)</h3><p>尝试根据此 bitmap 的尺寸制作一个新的 bitmap，将新 bitmap 的配置设置为指定的配置，然后将该 bitmap 的像素复制到新的位图中。如果不支持转换，或者分配器失败，则返回 NULL 。返回的 bitmap 具有与原始 bitmap 相同的密度和色彩空间，以下情况除外。复制到 Config.ALPHA_8 时，颜色空间将被删除。复制到 Config.RGBA_F16 或从 Config.RGBA_F16 复制时， EXTENDED 或 non-EXTENDED 变体可能会适当调整。</p><ul><li>Config config：生成的 bitmap 所需的配置。</li><li>boolean isMutable：是否结果 bitmap 是可变的（即像素可以修改）。</li></ul><h3 id="byte-getNinePatchChunk"><a href="#byte-getNinePatchChunk" class="headerlink" title="byte[] getNinePatchChunk()"></a>byte[] getNinePatchChunk()</h3><p>返回一个可选的私有数据数组，UI系统用于一些 bitmap 。不应由应用程序调用。</p><h3 id="boolean-compress-CompressFormat-format-int-quality-OutputStream-stream"><a href="#boolean-compress-CompressFormat-format-int-quality-OutputStream-stream" class="headerlink" title="boolean compress(CompressFormat format, int quality, OutputStream stream)"></a>boolean compress(CompressFormat format, int quality, OutputStream stream)</h3><p>将 bitmap 的压缩版本写入指定的输出流。如果返回true，则可以通过将相应的输入流传递给 BitmapFactory.decodeStream（）来重构位图。注意：不是所有格式都直接支持所有 bitmap 配置，因此从 BitmapFactory 返回的 bitmap 可能处于不同的位深中，并且/或者 丢失了每个像素的alpha（例如JPEG仅支持不透明像素）。</p><ul><li>CompressFormat format：压缩图像的格式</li><li>int qualit：给压缩器的提示，0-100。 0表示压缩已获得最低质量，100表示​​压缩以获得最高质量。某些格式（例如无损的PNG）将忽略该质量设置。</li><li>OutputStream stream：写入压缩数据的输出流。</li></ul><h3 id="final-boolean-isMutable"><a href="#final-boolean-isMutable" class="headerlink" title="final boolean isMutable()"></a>final boolean isMutable()</h3><p>返回 bitmap 是否为可变的。</p><h3 id="final-boolean-isPremultiplied"><a href="#final-boolean-isPremultiplied" class="headerlink" title="final boolean isPremultiplied()"></a>final boolean isPremultiplied()</h3><p>指示是否存储在此 bitmap 中的像素被预乘。 当像素预乘时，RGB 分量已乘以 alpha分量。例如，如果原始颜色为50％半透明红色（128，255，0，0），则预乘形式为（128，128，0，0）。</p><p>如果 getConfig() 为 Bitmap.Config.RGB_565 ，则方法始终返回false。</p><p>如果 getConfig() 为 Bitmap.Config.ALPHA_8 ，则方法返回值不确定。</p><p>仅当 hasAlpha() 返回 true 时，此方法才返回 true 。 没有alpha通道的 bitmap 既可以用作预乘位，也可以用作非预乘 bitmap 。</p><p>view 系统或 Canvas 只能绘制预乘的 bitmap。如果将带有 Alpha 通道的非预乘 bitmap 绘制到了 Canvas 上，则会抛出 RuntimeException。</p><h3 id="final-int-getWidth"><a href="#final-int-getWidth" class="headerlink" title="final int getWidth()"></a>final int getWidth()</h3><p>返回 bitmap 的宽度。</p><h3 id="final-int-getHeight"><a href="#final-int-getHeight" class="headerlink" title="final int getHeight()"></a>final int getHeight()</h3><p>返回 bitmap 的高度。</p><h3 id="int-getScaledWidth-Canvas-canvas"><a href="#int-getScaledWidth-Canvas-canvas" class="headerlink" title="int getScaledWidth(Canvas canvas)"></a>int getScaledWidth(Canvas canvas)</h3><p>使用给定 Canva 的目标密度调用 getScaledWidth(int) 的便捷方法。</p><h3 id="int-getScaledHeight-Canvas-canvas"><a href="#int-getScaledHeight-Canvas-canvas" class="headerlink" title="int getScaledHeight(Canvas canvas)"></a>int getScaledHeight(Canvas canvas)</h3><p>使用给定 Canva 的目标密度调用 getScaledWidth(int) 的便捷方法。</p><h3 id="int-getScaledWidth-DisplayMetrics-metrics"><a href="#int-getScaledWidth-DisplayMetrics-metrics" class="headerlink" title="int getScaledWidth(DisplayMetrics metrics)"></a>int getScaledWidth(DisplayMetrics metrics)</h3><p>使用给定 DisplayMetrics 的目标密度调用 getScaledWidth(int) 的便捷方法。</p><h3 id="int-getScaledHeight-DisplayMetrics-metrics"><a href="#int-getScaledHeight-DisplayMetrics-metrics" class="headerlink" title="int getScaledHeight(DisplayMetrics metrics)"></a>int getScaledHeight(DisplayMetrics metrics)</h3><p>使用给定 DisplayMetrics 的目标密度调用 getScaledWidth(int) 的便捷方法。</p><h3 id="int-getScaledWidth-int-targetDensity"><a href="#int-getScaledWidth-int-targetDensity" class="headerlink" title="int getScaledWidth(int targetDensity)"></a>int getScaledWidth(int targetDensity)</h3><p>返回此 bitmap 宽度除以密度比例因子的便捷方法。</p><p>返回 bitmap 的宽度乘以目标密度与 bitmap 的源密度的比率。</p><ul><li>int targetDensity：bitmap 的目标 canvas 的密度。</li></ul><h3 id="int-getScaledHeight-int-targetDensity"><a href="#int-getScaledHeight-int-targetDensity" class="headerlink" title="int getScaledHeight(int targetDensity)"></a>int getScaledHeight(int targetDensity)</h3><p>返回此 bitmap 高度除以密度比例因子的便捷方法。</p><p>返回 bitmap 的高度乘以目标密度与 bitmap 的源密度的比率。</p><ul><li>int targetDensity：bitmap 的目标 canvas 的密度。</li></ul><h3 id="final-int-getRowBytes"><a href="#final-int-getRowBytes" class="headerlink" title="final int getRowBytes()"></a>final int getRowBytes()</h3><p>返回 bitmap 像素中 行之间的字节数。请注意，指的是由 bitmap 由 native 存储的像素。如果调用 getPixels() 或 setPixels() ，则像素将被统一视为 32 位值，并根据Color类打包。</p><p>从 android.os.Build.VERSION_CODES.KITKAT （Android 4.4，19）开始，此方法不应用于计算 bitmap 的内存使用情况。而应使用 getAllocationByteCount() 。</p><h3 id="final-int-getByteCount"><a href="#final-int-getByteCount" class="headerlink" title="final int getByteCount()"></a>final int getByteCount()</h3><p>返回可用于存储该 bitmap 像素的最小字节数。</p><p>从 android.os.Build.VERSION_CODES.KITKAT （Android 4.4，19）开始，此方法不应用于计算 bitmap 的内存使用情况。而应使用 getAllocationByteCount() 。</p><h3 id="final-int-getAllocationByteCount"><a href="#final-int-getAllocationByteCount" class="headerlink" title="final int getAllocationByteCount()"></a>final int getAllocationByteCount()</h3><p>返回用于存储此 bitmap 像素的已分配内存的大小。</p><p>如果 bitmap 被重用以解码其他较小尺寸的 bitmap，或者通过手动重新配置，则此结果可能大于 getByteCount() 的结果。请参见 reconfigure(int，int，Config)，setWidth(int) ，setHeight(int) ，setConfig(Bitmap.Config) 和 BitmapFactory.Options.inBitmap 。如果未以这种方式修改 bitmap ，则此值将 getByteCount() 返回的值相同。</p><h3 id="final-Config-getConfig"><a href="#final-Config-getConfig" class="headerlink" title="final Config getConfig()"></a>final Config getConfig()</h3><p>如果 bitmap 的内部配置采用一种公共格式，则返回该配置，否则返回 null 。</p><h3 id="final-boolean-hasAlpha"><a href="#final-boolean-hasAlpha" class="headerlink" title="final boolean hasAlpha()"></a>final boolean hasAlpha()</h3><p>如果 bitmap 的配置支持每个像素的 alpha ，则返回true；如果像素可能包含非透明的 alpha 值，则返回。对于某些配置，始终为false（例如RGB_565），因为它们不支持按像素 alpha。但是，对于需要这样做的配置，可以将 bitmap 标记为知道其所有像素都是不透明的。在这种情况下，hasAlpha（）也将返回 false 。如果未对ARGB_8888之类的配置进行标记，则默认情况下将返回true。</p><h3 id="final-boolean-hasMipMap"><a href="#final-boolean-hasMipMap" class="headerlink" title="final boolean hasMipMap()"></a>final boolean hasMipMap()</h3><p>指示负责绘制此 bitmap 的渲染器是否应按比例缩小 bitmap 图时尝试使用 mipmaps 。</p><p>如果知道要以小于其原始大小的 50％绘制此 bitmap ，则可能可以获得更高的质量。</p><p>此属性只是一个渲染器可以忽略的建议。不能保证有任何效果。</p><h3 id="final-void-setHasMipMap-boolean-hasMipMap"><a href="#final-void-setHasMipMap-boolean-hasMipMap" class="headerlink" title="final void setHasMipMap(boolean hasMipMap)"></a>final void setHasMipMap(boolean hasMipMap)</h3><p>指示负责绘制此 bitmap 的渲染器是否应按比例缩小 bitmap 图时尝试使用 mipmaps 。</p><p>如果知道要以小于其原始大小的 50％绘制此 bitmap ，则可能可以获得更高的质量。</p><p>此属性只是一个渲染器可以忽略的建议。不能保证有任何效果。</p><ul><li>boolean hasMipMap；指示渲染器是否应尝试使用mipmaps。</li></ul><h3 id="final-ColorSpace-getColorSpace"><a href="#final-ColorSpace-getColorSpace" class="headerlink" title="final ColorSpace getColorSpace()"></a>final ColorSpace getColorSpace()</h3><p>返回与此 bitmap 关联的色彩空间。如果颜色空间未知，则此方法返回 null 。</p><h3 id="void-setColorSpace-NonNull-ColorSpace-colorSpace"><a href="#void-setColorSpace-NonNull-ColorSpace-colorSpace" class="headerlink" title="void setColorSpace(@NonNull ColorSpace colorSpace)"></a>void setColorSpace(@NonNull ColorSpace colorSpace)</h3><p>将 bitmap 识别为具有指定的 ColorSpace ，而不影响 bitma 的底层分配。</p><p>这影响 framework 层如何解释每个像素的颜色。具有 Config.ALPHA_8 的 bitmap 永远不会有颜色空间，因为颜色空间不会影响 a​​lpha 通道。其他 Config 一定具有非 null 的 ColorSpace。</p><h3 id="void-eraseColor-ColorInt-int-c"><a href="#void-eraseColor-ColorInt-int-c" class="headerlink" title="void eraseColor(@ColorInt int c)"></a>void eraseColor(@ColorInt int c)</h3><p>用指定的 Color 填充 bitmap 的像素。</p><h3 id="void-eraseColor-ColorLong-long-color"><a href="#void-eraseColor-ColorLong-long-color" class="headerlink" title="void eraseColor(@ColorLong long color)"></a>void eraseColor(@ColorLong long color)</h3><p>用指定的 ColorLong 填充 bitmap 的像素。</p><h3 id="int-getPixel-int-x-int-y"><a href="#int-getPixel-int-x-int-y" class="headerlink" title="int getPixel(int x, int y)"></a>int getPixel(int x, int y)</h3><p>返回指定位置的 Color 。如果 x 或 y 超出范围（负值或者分别大于等于宽度或高度，则抛出异常）。返回的颜色是 ColorSpace.Named.SRGB 颜色空间中的非预乘ARGB值。</p><ul><li>int x：要返回像素的x坐标（0 … width-1）。</li><li>int y：要返回像素的y坐标（0 … height-1）。</li></ul><h3 id="Color-getColor-int-x-int-y"><a href="#Color-getColor-int-x-int-y" class="headerlink" title="Color getColor(int x, int y)"></a>Color getColor(int x, int y)</h3><p>返回指定位置的 Color 。如果 x 或 y 超出范围（负值或者分别大于等于宽度或高度，则抛出异常）。返回的颜色是 ColorSpace.Named.SRGB 颜色空间中的非预乘ARGB值。</p><ul><li>int x：要返回像素的x坐标（0 … width-1）。</li><li>int y：要返回像素的y坐标（0 … height-1）。</li></ul><h3 id="void-getPixels-ColorInt-int-pixels-int-offset-int-stride-int-x-int-y-int-width-int-height"><a href="#void-getPixels-ColorInt-int-pixels-int-offset-int-stride-int-x-int-y-int-width-int-height" class="headerlink" title="void getPixels(@ColorInt int[] pixels, int offset, int stride, int x, int y, int width, int height)"></a>void getPixels(@ColorInt int[] pixels, int offset, int stride, int x, int y, int width, int height)</h3><p>以 pixel[] 数组的形式返回 bitmap 中数据的副本。每个值都是表示 Color 的包装 int 。 stride 参数允许调用方在行之间的返回像素数组中设置步长。对于正常的打包结果，只需通过宽度作为步长即可。 返回的颜色是 ColorSpace.Named.SRGB 颜色空间中的非预乘ARGB值。</p><ul><li>int[] pixels：接收 bitmap 颜色的数组。</li><li>int offset：写入像素的第一个索引[]。</li><li>int stride：要在行之间跳过的像素数[]的条目数（必须 &gt;= bitmap的宽度）。可以为负。</li><li>int x：从 bitmap 读取的第一个像素的 x 坐标。</li><li>int y：从 bitmap 读取的第一个像素的 y 坐标。</li><li>int width：每行要读取的像素数。</li><li>int height：要读取的行数。</li></ul><h3 id="void-setPixel-int-x-int-y-ColorInt-int-color"><a href="#void-setPixel-int-x-int-y-ColorInt-int-color" class="headerlink" title="void setPixel(int x, int y, @ColorInt int color)"></a>void setPixel(int x, int y, @ColorInt int color)</h3><p>在 x，y 坐标处将指定的 Color 写入 bitmap（假设 bitmap 是可变的）。颜色必须是 ColorSpace.Named.SRGB 颜色空间中的非预乘ARGB值。</p><ul><li>int x：要替换的像素的 x 坐标（0 … width-1）。</li><li>int y：要替换的像素的 y 坐标（0 … height-1）。</li><li>int color：写入 bitmap 的ARGB颜色。</li></ul><h3 id="void-setPixels-ColorInt-int-pixels-int-offset-int-stride-int-x-int-y-int-width-int-height"><a href="#void-setPixels-ColorInt-int-pixels-int-offset-int-stride-int-x-int-y-int-width-int-height" class="headerlink" title="void setPixels(@ColorInt int[] pixels, int offset, int stride, int x, int y, int width, int height)"></a>void setPixels(@ColorInt int[] pixels, int offset, int stride, int x, int y, int width, int height)</h3><p>用数组中的颜色替换 bitmap 中的像素。数组中的每个元素是一个包装 int ，表示 ColorSpace.Named.SRGB 颜色空间中未预乘的ARGB Color。</p><ul><li>int[] pixels：写入 bitma 的颜色数组。</li><li>int offset：从像素读取的第一种颜色的索引[]。</li><li>int stride：以像素为单位的颜色数，以在行之间跳过。通常，此值将与 bitmap 的宽度相同，但是可以更大（或为负）。</li><li>int x：bitmap 中要写入的第一个像素的 x 坐标。</li><li>int y：bitmap 中要写入的第一个像素的 y 坐标。</li><li>int width：每行要从 pixel[] 复制的颜色数。</li><li>int height：写入 bitmap 的行数。</li></ul><h3 id="Bitmap-extractAlpha"><a href="#Bitmap-extractAlpha" class="headerlink" title="Bitmap extractAlpha()"></a>Bitmap extractAlpha()</h3><p>返回捕获原始图像的 Alpha 值的新 bitmap。 可以使用Canvas.drawBitmap() 进行绘制，其中颜色将从传递给绘图调用的 paint 中获取。</p><h3 id="Bitmap-extractAlpha-Paint-paint-int-offsetXY"><a href="#Bitmap-extractAlpha-Paint-paint-int-offsetXY" class="headerlink" title="Bitmap extractAlpha(Paint paint, int[] offsetXY)"></a>Bitmap extractAlpha(Paint paint, int[] offsetXY)</h3><p>返回捕获原始图像的 Alpha 值的新 bitmap。 这些值可能会受到可选的Paint参数的影响，该参数可以包含自己的 alph 值，还可以包含 MaskFilter ，后者可以更改结果 bitmap 的实际尺寸（例如模糊 maskfilter 可能会放大结果 bitmap）。如果 offsetXY 不为 null ，则返回偏移返回 bitmap 的量，以便在逻辑上与原始对齐。例如，如果绘画包含半径为2的模糊，则 offsetXY[] 将包含 -2，-2，这样绘制 alpha 的 bitmap 偏移量为（-2，-2），然后绘制原图将使得模糊效果与原图在视觉上对齐。</p><ul><li>Paint paint：用于修改结果 bitmap 中的 alpha 值的可选画笔。为默认传递 null 。</li><li>int[] offsetXY：可选数组，该数组返回放置返回的 bitmpa 所需的 X（索引0）和 Y（索引1）偏移，以使其在视觉上与原始行对齐。</li></ul><h3 id="boolean-sameAs-Bitmap-other"><a href="#boolean-sameAs-Bitmap-other" class="headerlink" title="boolean sameAs(Bitmap other)"></a>boolean sameAs(Bitmap other)</h3><p>给定另一个 bitmap ，如果它具有与此 bitmap 相同的尺寸，配置，和像素数据，则返回true。如果其中任何一个不同，则返回false。 如果 other 为 null ，则返回 false 。</p><h3 id="void-prepareToDraw"><a href="#void-prepareToDraw" class="headerlink" title="void prepareToDraw()"></a>void prepareToDraw()</h3><p>构建与用于绘制 bitmap 的 bitmap 关联的缓存。</p><p>从 android.os.Build.VERSION_CODES.N（Android 7.0，24）开始，如果尚未上传 bitmap，则此调用会在 RenderThread 上启动异步上传到GPU。使用硬件加速时，必须将 bitmap 上传到GPU才能进行渲染。默认情况下，这是在第一次绘制 bitmap 时完成的，但是此过程可能需要几毫秒的时间，具体取决于 bitmap 的大小。每次修改并再次绘制 bitmap 时，都必须重新上传。</p><p>提前调用此方法可以节省使用第一帧的时间。例如，建议在解码的 bitmap 即将显示时在图像解码工作线程上调用此方法。建议在调用此方法之前对 bitmap 进行任何预绘制修改，以便可以重新使用缓存的上传副本，而无需重新上传。</p><p>在 android.os.Build.VERSION_CODES.KITKAT （Android 6.0，23）及以下版本中，对于可清除的 bitmap ，此调用将尝试确保像素已解码。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;基于9.0（29）简析Bitmap类。&lt;/p&gt;
&lt;p&gt;我们只关注Bitmap类暴露出来的（即访问权限为public）东西。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;枚举类Config&lt;/li&gt;
&lt;li&gt;枚举类CompressFormat&lt;/li&gt;
&lt;li&gt;若干 createBitmap 
      
    
    </summary>
    
      <category term="Android" scheme="https://codepoem.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="https://codepoem.github.io/tags/Android/"/>
    
      <category term="图片" scheme="https://codepoem.github.io/tags/%E5%9B%BE%E7%89%87/"/>
    
      <category term="Bitmap" scheme="https://codepoem.github.io/tags/Bitmap/"/>
    
  </entry>
  
  <entry>
    <title>简析BitmapFactory</title>
    <link href="https://codepoem.github.io/2019/10/14/%E7%AE%80%E6%9E%90BitmapFactory/"/>
    <id>https://codepoem.github.io/2019/10/14/简析BitmapFactory/</id>
    <published>2019-10-14T08:59:44.000Z</published>
    <updated>2019-10-14T08:59:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>基于9.0（29）简析BitmapFactory类。</p><p>我们只关注BitmapFactor类暴露出来的（即访问权限为public）东西。</p><ul><li>静态内部类Options</li><li>若干decode方法</li></ul><h2 id="静态内部类Options"><a href="#静态内部类Options" class="headerlink" title="静态内部类Options"></a>静态内部类Options</h2><p>Options，顾名思义，是BitmapFactory用于decode方法的选项参数。让我们看看有哪些：</p><h3 id="Bitmap-inBitmap"><a href="#Bitmap-inBitmap" class="headerlink" title="Bitmap inBitmap"></a>Bitmap inBitmap</h3><p>如果使用此参数，decode方法会在加载内容时尝试重用此 bitmap ，如果编码操作不能使用此 bitmap （有限制条件），则会抛出 java.lang.IllegalArgumentException 异常。当前的重用实现方式要求 bitmap 必须是可变的，并且即使一个资源在decode后通常会得到不可变的 bitmap，在重用成功后所得到的重用 bitmap 也将保持可变性。任何可变的 bitmap 都可以被 BitmapFactory 重用，以解码任何其他 bitmap，只要解码后的 bitmap （待分配内存）的字节数（getByteCount方法，解码后待分配内存状态的大小）小于或等于分配的字节数（getAllocationByteCount方法，占用内存的实际大小）。这可能是因为待分配内存的 bitmap 固有尺寸较小，或者其缩放后的尺寸（对于密度/样本尺寸）较小。</p><p>在android.os.Build.VERSION_CODES.KITKAT（Android4.4，19）之前，使用有更多限制：</p><ul><li>解码的图像（无论是作为资源还是作为流）必须为jpeg或png格式。</li><li>仅支持大小相等的 bitmap，并且 inSampleSize 设置为1。</li><li>另外，重用 bitmap 的 Bitmap.Config 配置 inPreferredConfig 将被覆盖（如果已设置）。</li></ul><p>BitmapRegionDecoder 会将其请求的内容绘制到提供的 bitmap 中，如果输出内容大小（缩放后）大于提供的 bitmap ，则进行裁剪。提供的 bitmap 的宽度，高度和 Bitmap.Config 不会更改。<br>android.os.Build.VERSION_CODES.JELLY_BEAN（Android 4.1，16）中引入了对inBitmap 的 BitmapRegionDecoder 支持。 BitmapRegionDecoder 支持的所有格式 通过 inBitmap 支持 bitmap 重用。</p><h3 id="boolean-inMutable"><a href="#boolean-inMutable" class="headerlink" title="boolean inMutable"></a>boolean inMutable</h3><p>在native代码中使用。</p><p>如果开启该设置，则 decode 方法将始终返回可变的 bitmap。这可以用于以编程方式将效果应用于通过BitmapFactory加载的Bitmap。不能与inPreferredConfig = Bitmap.Config.HARDWARE 同时设置，因为硬件 bitmap 始终是不可变的。</p><h3 id="boolean-inJustDecodeBounds"><a href="#boolean-inJustDecodeBounds" class="headerlink" title="boolean inJustDecodeBounds"></a>boolean inJustDecodeBounds</h3><p>如果开启该设置， 解码器将会返回 null （不返回 bitmap ），但是 out… 字段（如 outWidth 、 outHeight 、 outMimeType ）会被赋值，从而允许调用者查询 bitmap ，而不必为其像素分配内存。</p><h3 id="int-inSampleSize"><a href="#int-inSampleSize" class="headerlink" title="int inSampleSize"></a>int inSampleSize</h3><p>如果设置的值大于1，将会请求解码器对原始图像进行二次采样，返回较小的图像以节省内存。样本大小是任一维度中与已解码 bitmap 中单个像素对应的像素数。例如，设置 inSampleSize == 4 ，将会返回一张是宽高为原始宽度和高度的 1/4 的图像，像素为原来的 1/16。任何小于等于1的值都与1相同。注意：解码器使用基于2的幂的最终值，任何其他值将四舍五入为最接近的2的幂。</p><h3 id="Bitmap-Config-inPreferredConfig"><a href="#Bitmap-Config-inPreferredConfig" class="headerlink" title="Bitmap.Config inPreferredConfig"></a>Bitmap.Config inPreferredConfig</h3><p>如果该配置不为 null ，解码器将会尝试解析 bitmap 成此内部配置（bitmap 的像素存储方式）。如果该配置为 null，或者无法满足要求，解码器将会基于系统屏幕深度和原始图像的特征（如是否有每像素透明度）来选择最合适的配置（要求该配置也满足要求）。</p><p>图像默认以Bitmap.Config.ARGB_8888的配置加载。</p><h3 id="ColorSpace-inPreferredColorSpace"><a href="#ColorSpace-inPreferredColorSpace" class="headerlink" title="ColorSpace inPreferredColorSpace"></a>ColorSpace inPreferredColorSpace</h3><p>如果改配置不为 null ，则解码器将尝试解码 bitmap 到此颜色空间中。如果该配置为 null ，或者无法满足要求，则解码器将选择嵌在图像的颜色空间或最适合请求的图像配置的颜色空间（例如，ColorSpace.Named.SRGB 对应 Bitmap.Config.ARGB_8888 ; ColorSpace.Named.EXTENDED_SRGB 对应 Bitmap.Config.RGBA_F16）。</p><p>目前只支持 ColorSpace.Model.RGB 颜色空间，如果设置了非RGB颜色空间（例如 ColorSpace.Named.CIE_LAB）， decode 方法将会抛出异常（IllegalArgumentException）。</p><p>指定的色彩空间的传递函数必须是 ColorSpace.Rgb.TransferParameters() ICC参数曲线。如果在指定的色彩空间调用方法 ColorSpace.Rgb.getTransferParameters() 返回 null ， decode 方法将会抛出异常（IllegalArgumentException）。</p><p>解码之后，bitmap 的色彩空间存储在 BitmapFactory.Options.outColorSpace 字段。</p><h3 id="boolean-inPremultiplied"><a href="#boolean-inPremultiplied" class="headerlink" title="boolean inPremultiplied"></a>boolean inPremultiplied</h3><p>如果开启此配置（默认开启），则生成的 bitmap 的颜色通道将被alpha通道预乘。</p><p>由视图系统或通过 Canvas 直接绘制的图像，不应将其设置为false。视图系统和 Canvas 假定所有绘制的图像都已预乘以简化绘制时融合，并且在绘制未预乘时将抛出 RuntimeException 。</p><p>仅当您要处理原始编码的图像数据（例如，使用RenderScript或自定义OpenGL）时才是合适的。</p><p>不会影响没有Alpha通道的 bitmap 。</p><p>将 inScaled 设置为true时将此标志设置为false可能会导致颜色错误。</p><h3 id="boolean-inDither"><a href="#boolean-inDither" class="headerlink" title="boolean inDither"></a>boolean inDither</h3><p>@deprecated 自android.os.Build.VERSION_CODES.N （Android7.0，24）起，此配置被忽略。</p><p>在 android.os.Build.VERSION_CODES.M (Android6.0，23)及以下版本中，如果设置为true，则解码器将尝试对解码的图像进行抖动。</p><h3 id="int-inDensity"><a href="#int-inDensity" class="headerlink" title="int inDensity"></a>int inDensity</h3><p>用于 bitmap 像素密度。这将使得在返回的位图中始终有为其设置的密度（请参阅 Bitmap.setDensity(int)）。此外，如果开启了 inScaled（默认情况下开启），并且此密度与 inTargetDensity 不匹配，则 bitmap 在返回之前将被缩放为目标密度。</p><p>如果设置为0， BitmapFactory.decodeResource(Resources, int) 、 BitmapFactory.decodeResource(Resources, int, android.graphics.BitmapFactory.Options) 、 BitmapFactory.decodeResourceStream 这些 decode 方法将填充与资源关联的密度。其他 decode 方法将保持原样，并且不会应用任何密度。</p><h3 id="int-inTargetDensity"><a href="#int-inTargetDensity" class="headerlink" title="int inTargetDensity"></a>int inTargetDensity</h3><p>此 bitmap 将被绘制到的目标像素密度。 与 inDensity 和 inScaled 结合使用，以确定在返回 bitmap 之前是否以及如何缩放位图。</p><p>如果设置为0， BitmapFactory.decodeResource(Resources, int) 、 BitmapFactory.decodeResource(Resources, int, android.graphics.BitmapFactory.Options) 、 BitmapFactory.decodeResourceStream 这些 decode 方法将填充与资源对象的 DisplayMetrics 相关的密度。其他 decode 方法将保持原样，并且不会对密度进行缩放。</p><h3 id="int-inScreenDensity"><a href="#int-inScreenDensity" class="headerlink" title="int inScreenDensity"></a>int inScreenDensity</h3><p>正在使用的实际屏幕的像素密度。 仅用于以密度兼容代码运行的应用程序，其中 inTargetDensity 实际上是应用程序看到的密度而不是实际的屏幕密度。</p><p>通过设置此选项，允许加载代码避免将当前的屏幕密度的 bitmap 缩放到/降低到兼容密度。相反的，如果 inDensity 与 inScreenDensity 相同，则 bitmap 将保持不变。任何使用生成的 bitmap 的对象，还必须使用 Bitmap.getScaledWidth 和 Bitmap.getScaledHeight 来说明 bitmap 的密度与目标密度之间的任何差异。</p><p>BitmapFactory 自身永远不会为调用者自动设置。必须明确设置它，因为调用者必须以密度感知的方式处理结果位图。</p><h3 id="boolean-inScaled"><a href="#boolean-inScaled" class="headerlink" title="boolean inScaled"></a>boolean inScaled</h3><p>如果设置了该配置，并且 inDensity 和 inTargetDensity 不为 0，bitmap 在加载时将缩放以匹配 inTargetDensity，而不是每次绘制到 Canvas 时都依赖于图形系统对其进行缩放。</p><p>BitmapRegionDecoder 会忽略这个配置，并且不会根据密度缩放输出。（尽管支持 inSampleSize ）</p><p>此配置默认开启，如果需要 bitmap 的非缩放版本，则应将其关闭。.9 bitmaps（Nine-patch bitmaps）会忽略此配置，并且始终会缩放。</p><p>如果 inPremultiplied 设置为 false ，并且图像具有 Alpha透明度，将此配置设置为 true 可能会导致颜色错误。</p><h3 id="boolean-inPurgeable"><a href="#boolean-inPurgeable" class="headerlink" title="boolean inPurgeable"></a>boolean inPurgeable</h3><p>@deprecated 自 android.os.Build.VERSION_CODES.LOLLIPOP（Android5.0，21） 起，此配置被忽略。</p><p>在 android.os.Build.VERSION_CODES.KITKAT（Android4.4，19）及以下版本中，如果将此配置设置为 true ，那么生成的 bitmap 将分配其像素，以便在系统需要回收内存时可以将其清除。在那种情况下，当需要再次访问像素时（例如绘制 bitmap，调用getPixels（）），它们将被自动重新解码。</p><p>为了进行重新解码，bitmap 必须通过共享对输入的引用或对其进行复制来访问编码的数据。此区别由 inInputShareable 控制。如果 inInputShareable 为 true，则 bitmap 可能会保留对输入的浅引用。如果这 inInputShareable 为 false，则 bitmap 将显式地复制输入数据，并将其保留。即使允许共享，实现仍可以决定对输入数据进行深拷贝。</p><p>尽管 inPurgeable 可以帮助避免大的Dalvik堆分配（从API级别11开始），但是它牺牲了性能可预测性，因为视图系统尝试绘制的任何图像都可能会导致解码延迟，从而导致帧丢失。因此，大多数应用应避免使用 inPurgeable 来提供快速流畅的UI。为了最小化Dalvik堆分配，请使用 inBitmap 配置。</p><p>该配置会被decodeResource(Resources, int, android.graphics.BitmapFactory.Options) 或者 decodeFile(String,<br>android.graphics.BitmapFactory.Options)</p><h3 id="boolean-inInputShareable"><a href="#boolean-inInputShareable" class="headerlink" title="boolean inInputShareable"></a>boolean inInputShareable</h3><p>@deprecated 自 android.os.Build.VERSION_CODES.LOLLIPOP（Android5.0，21） 起，此配置被忽略。</p><p>在 android.os.Build.VERSION_CODES.KITKAT（Android4.4，19）及以下版本中，此配置与 inPurgeable 结合使用。如果 inPurgeable 为 false ，则会忽略此字段。如果 inPurgeable 为 true ，则配置确定 bitmap 是否可以共享对输数据（inputstream，数组等）的引用，或者是否必须进行深拷贝。</p><h3 id="boolean-inPreferQualityOverSpeed"><a href="#boolean-inPreferQualityOverSpeed" class="headerlink" title="boolean inPreferQualityOverSpeed"></a>boolean inPreferQualityOverSpeed</h3><p>@deprecated自 android.os.Build.VERSION_CODE.N （Android7.0，24）起，此配置被忽略。输出将始终是高质量的。</p><p>在 android.os.Build.VERSION_CODES.M (Android6.0，23)及以下版本中，如果将 inPreferQualityOverSpeed 设置为 true ，则解码器将尝试以牺牲解码速度为代价，将重构图像解码为更高质量的图像。当前该字段仅影响 JPEG 解码，在这种情况下，将使用更准确但稍慢的 IDCT 方法代替。</p><h3 id="int-outWidth"><a href="#int-outWidth" class="headerlink" title="int outWidth"></a>int outWidth</h3><p>bitmap 的解码结果宽度。如果 inJustDecodeBounds 设置为false，这将是应用所有缩放后输出 bitmap 的宽度。如果为true，它将是输入图像的宽度，不考虑缩放。</p><p>如果尝试解码时发生错误，outWidth将设置为-1。</p><h3 id="int-outHeight"><a href="#int-outHeight" class="headerlink" title="int outHeight"></a>int outHeight</h3><p>bitmap 的解码结果高度。如果 inJustDecodeBounds 设置为false，这将是应用所有缩放后输出 bitmap 的高度。如果为true，它将是输入图像的高度，不考虑缩放。</p><p>如果尝试解码时发生错误，outHeight将设置为-1。</p><h3 id="String-outMimeType"><a href="#String-outMimeType" class="headerlink" title="String outMimeType"></a>String outMimeType</h3><p>如果明确，则将该字符串设置为解码图像的媒体类型。 如果未知或有错误，则将其设置为 null 。</p><h3 id="Bitmap-Config-outConfig"><a href="#Bitmap-Config-outConfig" class="headerlink" title="Bitmap.Config outConfig"></a>Bitmap.Config outConfig</h3><p>如果明确，为解码 bitmap 具有的像素存储方式配置。 如果未知或有错误，则将其设置为 null 。</p><h3 id="ColorSpace-outColorSpace"><a href="#ColorSpace-outColorSpace" class="headerlink" title="ColorSpace outColorSpace"></a>ColorSpace outColorSpace</h3><p>如果明确，为解码后的 bitmap 具有的色彩空间。注意，输出颜色空间不保证是 bitmap 编码的颜色空间。如果未知（例如，配置为 Bitmap.Config.ALPHA_8）或存在错误，则将其设置为 null 。</p><h3 id="byte-inTempStorage"><a href="#byte-inTempStorage" class="headerlink" title="byte[] inTempStorage"></a>byte[] inTempStorage</h3><p>用于解码的临时存储。建议16K左右。</p><h3 id="boolean-mCancel"><a href="#boolean-mCancel" class="headerlink" title="boolean mCancel"></a>boolean mCancel</h3><p>@deprecated 自 android.os.Build.VERSION_CODES.N （Android7.0，24）起。</p><p>指示已在此对象上调用cancel的标志。如果有一个中间人想要首先解码边界然后解码图像，则此配置很有用。在那种情况下，中间人可以在边界解码和图像解码之间检查是否取消了该操作。</p><h3 id="public-void-requestCancelDecode"><a href="#public-void-requestCancelDecode" class="headerlink" title="public void requestCancelDecode()"></a>public void requestCancelDecode()</h3><p>@deprecated 自 android.os.Build.VERSION_CODES.N （Android7.0，24）起，不影响解码，尽管设置了mCancel的值为true。</p><p>在 android.os.Build.VERSION_CODES.M (Android6.0，23)及以下版本。调用此命令将通知解码器应该取消其操作。这不能保证取消解码，但是如果成功取消解码，则解码器操作结果将返回 null ，或者如果 inJustDecodeBounds 为 true ，则将outWidth / outHeight 设置为-1。</p><h2 id="decode-方法"><a href="#decode-方法" class="headerlink" title="decode 方法"></a>decode 方法</h2><h3 id="decode-方法简析"><a href="#decode-方法简析" class="headerlink" title="decode 方法简析"></a>decode 方法简析</h3><h4 id="Bitmap-decodeFile-String-pathName-Options-opts"><a href="#Bitmap-decodeFile-String-pathName-Options-opts" class="headerlink" title="Bitmap decodeFile(String pathName, Options opts)"></a>Bitmap decodeFile(String pathName, Options opts)</h4><p>将文件路径解码为 bitmap 。如果指定的文件名为 null ，或无法解码为 bitmap，则该函数返回 null 。</p><ul><li>String pathName：待解码文件的完整路径名</li><li>Options opts：控制下采样以及是否应完全解码图像或仅返回尺寸的选项参数，可为 null。</li></ul><p>实际内部调用了另外一个 decode 方法：<br>Bitmap decodeStream(@Nullable InputStream is, @Nullable Rect outPadding, @Nullable Options opts)<br>（参数 String pathName -&gt; InputStream is, Rect null , Options opts）</p><h4 id="Bitmap-decodeFile-String-pathName"><a href="#Bitmap-decodeFile-String-pathName" class="headerlink" title="Bitmap decodeFile(String pathName)"></a>Bitmap decodeFile(String pathName)</h4><p>重载 Bitmap decodeFile(String pathName, Options opts)</p><p>decodeFile(pathName, null);</p><h4 id="Bitmap-decodeResourceStream-Nullable-Resources-res-Nullable-TypedValue-value-Nullable-InputStream-is-Nullable-Rect-pad-Nullable-Options-opts"><a href="#Bitmap-decodeResourceStream-Nullable-Resources-res-Nullable-TypedValue-value-Nullable-InputStream-is-Nullable-Rect-pad-Nullable-Options-opts" class="headerlink" title="Bitmap decodeResourceStream(@Nullable Resources res, @Nullable TypedValue value, @Nullable InputStream is, @Nullable Rect pad, @Nullable Options opts)"></a>Bitmap decodeResourceStream(@Nullable Resources res, @Nullable TypedValue value, @Nullable InputStream is, @Nullable Rect pad, @Nullable Options opts)</h4><p>从InputStream解码新的 bitmap 。此InputStream是从资源获得的，我们通过传递这些资源可以相应地缩放位图。</p><h4 id="Bitmap-decodeResource-Resources-res-int-id-Options-opts"><a href="#Bitmap-decodeResource-Resources-res-int-id-Options-opts" class="headerlink" title="Bitmap decodeResource(Resources res, int id, Options opts)"></a>Bitmap decodeResource(Resources res, int id, Options opts)</h4><p>打开给定的资源并且调用 decodeResourceStream 方法的代名词。</p><ul><li>Resources res：包含图像数据的资源对象。</li><li>int id：图像数据的资源ID。</li><li>Options opts：控制下采样以及是否应完全解码图像或仅返回尺寸的选项参数，可为 null。</li></ul><p>实际内部调用了另外一个 decode 方法：<br>decodeResourceStream(@Nullable Resources res, @Nullable TypedValue value, @Nullable InputStream is, @Nullable Rect pad, @Nullable Options opts)<br>（参数 Resources res, TypedValue value = new TypedValue(), InputStream res.openRawResource(id, value), Rect null, Options opts）</p><h4 id="Bitmap-decodeResource-Resources-res-int-id"><a href="#Bitmap-decodeResource-Resources-res-int-id" class="headerlink" title="Bitmap decodeResource(Resources res, int id)"></a>Bitmap decodeResource(Resources res, int id)</h4><p>重载 Bitmap decodeResource(Resources res, int id, Options opts)</p><p>decodeResource(res, id, null);</p><h4 id="Bitmap-decodeByteArray-byte-data-int-offset-int-length-Options-opts"><a href="#Bitmap-decodeByteArray-byte-data-int-offset-int-length-Options-opts" class="headerlink" title="Bitmap decodeByteArray(byte[] data, int offset, int length, Options opts)"></a>Bitmap decodeByteArray(byte[] data, int offset, int length, Options opts)</h4><p>从指定的字节数组解码不可变的 bitmap。</p><ul><li>byte[] data：压缩图像数据的字节数组。</li><li>int offset：解码器应开始解析的imageData的偏移量。</li><li>int length：从偏移量开始解析的字节数。</li><li>Options opts：控制下采样以及是否应完全解码图像或仅返回尺寸的选项参数，可为 null。</li></ul><p>调用 native 解码方法：<br>private static native Bitmap nativeDecodeByteArray(byte[] data, int offset, int length, Options opts, long inBitmapHandle, long colorSpaceHandle)</p><h4 id="Bitmap-decodeByteArray-byte-data-int-offset-int-length"><a href="#Bitmap-decodeByteArray-byte-data-int-offset-int-length" class="headerlink" title="Bitmap decodeByteArray(byte[] data, int offset, int length)"></a>Bitmap decodeByteArray(byte[] data, int offset, int length)</h4><p>重载 Bitmap decodeByteArray(byte[] data, int offset, int length, Options opts)</p><p>decodeByteArray(data, offset, length, null);</p><h4 id="Bitmap-decodeStream-Nullable-InputStream-is-Nullable-Rect-outPadding-Nullable-Options-opts"><a href="#Bitmap-decodeStream-Nullable-InputStream-is-Nullable-Rect-outPadding-Nullable-Options-opts" class="headerlink" title="Bitmap decodeStream(@Nullable InputStream is, @Nullable Rect outPadding, @Nullable Options opts)"></a>Bitmap decodeStream(@Nullable InputStream is, @Nullable Rect outPadding, @Nullable Options opts)</h4><p>将输入流解码为 bitmap 。如果输入流为 null ，或者不能用于解码 bitmap ，则该函数返回 null 。 流的位置将是读取编码数据之后的位置。</p><ul><li>InputStream is：输入流，其中包含要解码为 bitmap 的原始数据。</li><li>Rect outPadding：如果不为 null ，则返回 bitmap 的填充矩形（如果存在），否则将填充设置为[-1，-1，-1，-1]。如果没有 bitmap 返回（ null ），则填充是不变的。</li><li>Options opts：控制下采样以及是否应完全解码图像或仅返回尺寸的选项参数，可为 null。</li></ul><p>如果输入流是 AssetManager.AssetInputStrea，调用 native 解码方法：<br>private static native Bitmap nativeDecodeAsset(long nativeAsset, Rect padding, Options opts,<br>            long inBitmapHandle, long colorSpaceHandle)<br>否则调用私有内部方法：<br>Bitmap decodeStreamInternal(@NonNull InputStream is, @Nullable Rect outPadding, @Nullable Options opts)</p><h4 id="decodeStream-InputStream-is"><a href="#decodeStream-InputStream-is" class="headerlink" title="decodeStream(InputStream is)"></a>decodeStream(InputStream is)</h4><p>重载 Bitmap decodeStream(@Nullable InputStream is, @Nullable Rect outPadding, @Nullable Options opts)</p><p>decodeStream(is, null, null);</p><h4 id="Bitmap-decodeFileDescriptor-FileDescriptor-fd-Rect-outPadding-Options-opts"><a href="#Bitmap-decodeFileDescriptor-FileDescriptor-fd-Rect-outPadding-Options-opts" class="headerlink" title="Bitmap decodeFileDescriptor(FileDescriptor fd, Rect outPadding, Options opts)"></a>Bitmap decodeFileDescriptor(FileDescriptor fd, Rect outPadding, Options opts)</h4><p>从文件描述符解码 bitmap 。如果 bitmap 无法解码返回 null 。当返回时，描述符中的位置不会更改，因此可以按原样再次使用描述符。</p><ul><li>FileDescriptor fd：包含要解码的 bitmap 数据的文件描述符。</li><li>Rect outPadding：如果不为 null ，则返回 bitmap 的填充矩形（如果存在），否则将填充设置为[-1，-1，-1，-1]。如果没有 bitmap 返回（ null ），则填充是不变的。</li><li>Options opts：控制下采样以及是否应完全解码图像或仅返回尺寸的选项参数，可为 null。</li></ul><h4 id="Bitmap-decodeFileDescriptor-FileDescriptor-fd"><a href="#Bitmap-decodeFileDescriptor-FileDescriptor-fd" class="headerlink" title="Bitmap decodeFileDescriptor(FileDescriptor fd)"></a>Bitmap decodeFileDescriptor(FileDescriptor fd)</h4><p>重载Bitmap decodeFileDescriptor(FileDescriptor fd, Rect outPadding, Options opts)</p><p>decodeFileDescriptor(fd, null, null);</p><h3 id="decode-方法总结"><a href="#decode-方法总结" class="headerlink" title="decode 方法总结"></a>decode 方法总结</h3><p>所有的 decode 方法最后都会走下面三个 decode 方法：</p><p>Bitmap decodeStream(@Nullable InputStream is, @Nullable Rect outPadding, @Nullable Options opts)</p><p>Bitmap decodeByteArray(byte[] data, int offset, int length, Options opts)</p><p>Bitmap decodeFileDescriptor(FileDescriptor fd, Rect outPadding, Options opts)</p><p>其中 decodeStream 和 decodeFileDescriptor 方法 有可能走以下这个方法：</p><p>Bitmap decodeStreamInternal(@NonNull InputStream is, @Nullable Rect outPadding, @Nullable Options opts)</p><p>实质是调用了 native 解码方法：<br>Bitmap nativeDecodeStream(InputStream is, byte[] storage, Rect padding, Options opts, long inBitmapHandle, long colorSpaceHandle)</p><p>因此 native 以下四个方法是 decode 的最终归宿：</p><ul><li>private static native Bitmap nativeDecodeStream(InputStream is, byte[] storage, Rect padding, Options opts, long inBitmapHandle, long colorSpaceHandle);</li><li>private static native Bitmap nativeDecodeFileDescriptor(FileDescriptor fd, Rect padding, Options opts, long inBitmapHandle, long colorSpaceHandle);</li><li>private static native Bitmap nativeDecodeAsset(long nativeAsset, Rect padding, Options opts, long inBitmapHandle, long colorSpaceHandle);</li><li>private static native Bitmap nativeDecodeByteArray(byte[] data, int offset, int length, Options opts, long inBitmapHandle, long colorSpaceHandle);</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;基于9.0（29）简析BitmapFactory类。&lt;/p&gt;
&lt;p&gt;我们只关注BitmapFactor类暴露出来的（即访问权限为public）东西。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;静态内部类Options&lt;/li&gt;
&lt;li&gt;若干decode方法&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 i
      
    
    </summary>
    
      <category term="Android" scheme="https://codepoem.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="https://codepoem.github.io/tags/Android/"/>
    
      <category term="图片" scheme="https://codepoem.github.io/tags/%E5%9B%BE%E7%89%87/"/>
    
      <category term="Bitmap" scheme="https://codepoem.github.io/tags/Bitmap/"/>
    
  </entry>
  
  <entry>
    <title>Android图片压缩</title>
    <link href="https://codepoem.github.io/2019/10/14/Android%E5%9B%BE%E7%89%87%E5%8E%8B%E7%BC%A9/"/>
    <id>https://codepoem.github.io/2019/10/14/Android图片压缩/</id>
    <published>2019-10-14T08:59:44.000Z</published>
    <updated>2019-10-14T08:59:46.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为什么要压缩"><a href="#为什么要压缩" class="headerlink" title="为什么要压缩"></a>为什么要压缩</h2><h3 id="减少内存占用"><a href="#减少内存占用" class="headerlink" title="减少内存占用"></a>减少内存占用</h3><p>内存占用大小 = Bitmap大小 = 总像素点数 x 一个像素点占用的字节数</p><h4 id="Bitmap"><a href="#Bitmap" class="headerlink" title="Bitmap"></a>Bitmap</h4><p><strong>Android中图片在内存中的表达形式是Bitmap，即位图。</strong></p><h5 id="总像素点数"><a href="#总像素点数" class="headerlink" title="总像素点数"></a>总像素点数</h5><p><strong>总像素点数由什么决定呢？</strong></p><p>总像素点数 = 图片源长度 x 缩放比例 x 图片源宽度 x 缩放比例</p><p>缩放比例可以大致表示为：（为什么说大致呢？因为不是绝对的，实际还有其他因素可以影响实际缩放比例，如inScreenDensity）<br>缩放比例 = 1/inSampleSize x (inTargetDensity/inDensity)</p><ul><li>int inSampleSize</li></ul><p>如果设置的值大于1，将会请求解码器对原始图像进行二次采样，返回较小的图像以节省内存。样本大小是任一维度中与已解码 bitmap 中单个像素对应的像素数。例如，设置 inSampleSize == 4 ，将会返回一张是宽高为原始宽度和高度的 1/4 的图像，像素为原来的 1/16。任何小于等于1的值都与1相同。注意：解码器使用基于2的幂的最终值，任何其他值将四舍五入为最接近的2的幂。</p><ul><li>int inDensity</li></ul><p>用于 bitmap 像素密度。这将使得在返回的位图中始终有为其设置的密度（请参阅 Bitmap.setDensity(int)）。此外，如果开启了 inScaled（默认情况下开启），并且此密度与 inTargetDensity 不匹配，则 bitmap 在返回之前将被缩放为目标密度。</p><p>如果设置为0， BitmapFactory.decodeResource(Resources, int) 、 BitmapFactory.decodeResource(Resources, int, android.graphics.BitmapFactory.Options) 、 BitmapFactory.decodeResourceStream 这些 decode 方法将填充与资源关联的密度。其他 decode 方法将保持原样，并且不会应用任何密度。</p><ul><li>int inTargetDensity</li></ul><p>此 bitmap 将被绘制到的目标像素密度。 与 inDensity 和 inScaled 结合使用，以确定在返回 bitmap 之前是否以及如何缩放位图。</p><p>如果设置为0， BitmapFactory.decodeResource(Resources, int) 、 BitmapFactory.decodeResource(Resources, int, android.graphics.BitmapFactory.Options) 、 BitmapFactory.decodeResourceStream 这些 decode 方法将填充与资源对象的 DisplayMetrics 相关的密度。其他 decode 方法将保持原样，并且不会对密度进行缩放。</p><ul><li>int inScreenDensity</li></ul><p>正在使用的实际屏幕的像素密度。 仅用于以密度兼容代码运行的应用程序，其中 inTargetDensity 实际上是应用程序看到的密度而不是实际的屏幕密度。</p><p>通过设置此选项，允许加载代码避免将当前的屏幕密度的 bitmap 缩放到/降低到兼容密度。相反的，如果 inDensity 与 inScreenDensity 相同，则 bitmap 将保持不变。任何使用生成的 bitmap 的对象，还必须使用 Bitmap.getScaledWidth 和 Bitmap.getScaledHeight 来说明 bitmap 的密度与目标密度之间的任何差异。</p><p>BitmapFactory 自身永远不会为调用者自动设置。必须明确设置它，因为调用者必须以密度感知的方式处理结果位图。</p><ul><li>boolean inScaled</li></ul><p>如果设置了该配置，并且 inDensity 和 inTargetDensity 不为 0，bitmap 在加载时将缩放以匹配 inTargetDensity，而不是每次绘制到 Canvas 时都依赖于图形系统对其进行缩放。</p><p>BitmapRegionDecoder 会忽略这个配置，并且不会根据密度缩放输出。（尽管支持 inSampleSize ）</p><p>此配置默认开启，如果需要 bitmap 的非缩放版本，则应将其关闭。.9 bitmaps（Nine-patch bitmaps）会忽略此配置，并且始终会缩放。</p><p>如果 inPremultiplied 设置为 false ，并且图像具有 Alpha透明度，将此配置设置为 true 可能会导致颜色错误。</p><h5 id="一个像素点占用的字节数"><a href="#一个像素点占用的字节数" class="headerlink" title="一个像素点占用的字节数"></a>一个像素点占用的字节数</h5><p><strong>一个像素点占用的字节数由什么决定呢？</strong></p><blockquote><p>像素信息:</p><ul><li>像素不是一个具体的物理量，是一种抽象的数据结构。</li></ul><p>如果把一张图片看成是一堆信息元素的集合，那么为了描述一张图片，我们要先建模，用一个数据结构来表示信息元素。从而，建模后图像就成了一堆数据结构（结构体）的集合，现在给这种数据结构起个名字就叫像素。</p><ul><li>像素这种数据结构中可以记录颜色信息（因为图像就是由不同颜色组成的）。</li></ul></blockquote><blockquote><p>色彩空间（ColorSpace），对色彩的组织方式，RGB、YUV、CMYK等。</p><ul><li>RGB：一个像素划分Red、Green、Blue分量来表示，面向硬件，适合显示系统,不适合图像处理。</li><li>YUV：Y表示明亮度（Luminance，Luma，黑白信号），UV表示色度、浓度（Chrominance，Chroma，色彩信息）。</li><li>CMYK：C：Cyan ＝ 青色，常被误称为“天蓝色”或“湛蓝”，M：Magenta ＝ 洋红色，又称为“品红色”，Y：Yellow ＝ 黄色，K：blacK ＝ 黑色，是彩色印刷时采用的一种套色模式，利用色料的三原色混色原理，加上黑色油墨，共计四种颜色混合叠加，形成所谓“全彩印刷”。</li></ul><p>色彩模式是数字世界中表示颜色的一种算法。</p></blockquote><p><strong>因此一个像素点占用的字节由存储像素信息的方案决定。</strong></p><p>假设我们采用ARGB色彩模式，即在RGB色彩空间的基础上加上Alpha（透明度）通道。每个通道的取值范围在[0,255]，即有256个值，刚好可以用一个字节（8bit）表示。ARGB四个通道，需要四个字节表示一个像素信息。</p><p>事实上，在保证必要的像素信息的同时追求更少的内存占用，可以减少通道的位数，甚至可以考虑去掉Alpha（透明度）通道。</p><p><strong>Bitmap.Config是一个枚举类，它表示的就是每个像素点信息的存储方案。</strong><br>| Config    | 每个像素占用字节数                           | 表示颜色种数          | 说明                                                                   |<br>| ——— | ——————————————– | ——————— | ———————————————————————- |<br>| ALPHA_8   | 1个字节，A分量占8位，不存储颜色信息          | 0                     | 单透明通道                                                             |<br>| RGB_565   | 两个字节，R分量占5位，G分量占6位，B分量占5位 | 2^16(65536)           | 简易RGB色调                                                            |<br>| RGB_888   | 三个字节，R、G、B分量各占8位                 | 2^24(16777216)        | RGB色调                                                                |<br>| ARGB_4444 | 两个字节，A、R、G、B分量各占4位              | 2^12(4096)            | 已弃用，成像效果比较差，并且v4.4+后如果使用了它会自动转成用ARGB_8888。 |<br>| ARGB_8888 | 四个字节，A、R、G、B分量各占8位              | 2^24(16777216)        | 24位真彩色，Android中默认的配置                                                             |<br>| RGBA_F16  | 八个字节，A、R、G、B分量各占16位             | 2^48(281474976710656) | 特别适合于宽色域和HDR内容，在8.0（api 26）引入。                       |<br>| HARDWARE  | -                                            | -                     | 特殊配置。bitmap始终存储在图形内存中，在8.0（api 26）引入。            |</p><h3 id="减少物理空间占用"><a href="#减少物理空间占用" class="headerlink" title="减少物理空间占用"></a>减少物理空间占用</h3><p>物理空间占用 = 簇（操作系统所使用的逻辑概念）的整数倍 &gt;= 文件大小</p><p>图片在物理空间的表现形式是File，具体有GIF、JPEG、BMP、PNG和WebP等格式。</p><blockquote><ul><li>Gif<br>Gif是一种基于LZW算法的无损压缩格式，其压缩率一般在50％左右。Gif可插入多帧，从而实现动画效果。因此Gif图片分为静态GIF和动画GIF两种GIF格式。由于Gif以8位颜色压缩存储单个位图，所以它最多只能用256种颜色来表现物体，对于色彩复杂的物体它就力不从心了。因此Gif不适合用于色彩非常丰富的图片的压缩存储，比如拍摄的真彩图片等。</li><li>BMP<br>BMP是标准图形格式，它是包括Windows在内多种操作系统图像展现的终极形式。其本质就是Bitmap对象直接持久化保存的位图文件格式，由于没有进行压缩存储，因此体积非常大，故而不适合在网络上传输。同时也是因为这种格式是对Bitmap对象的直接存储而没有进行压缩，因此我们在讨论压缩格式时往往忽略这一种。</li><li>PNG<br>PNG格式本身的设计目的是替代GIF格式，所以它与GIF 有更多相似的地方。PNG格式也属于无损压缩，其位深为32位，也就是说它支持所有的颜色类型。同样是无损压缩，PNG的压缩率高于Gif格式，而且PNG支持的颜色数量也远高于Gif，因此：如果是对静态图片进行无损压缩，优先使用PNG取代Gif，因为PNG压缩率高、色彩好；但是PNG不支持动画效果。所以Gif仍然有用武之地。<br>PNG缺点是：由于是无损压缩，因此PNG文件的体积往往比较大。如果在项目中多处使用PNG图片文件，那么在APP瘦身时需要对PNG文件进行优化以减少APP体积大小。具体做法后面会详细介绍。</li><li>JPEG<br>JPEG是一种有损压缩格式，JPEG图片以24位颜色压缩存储单个位图。也就是说，JPEG不支持透明通道。JPEG也不支持多帧动画。因为是有损压缩，所以需要注意控制压缩率以免图片质量太差。<br>JPG和JPEG没有区别，全名、正式扩展名是JPEG。但因DOS、Windows95等早期系统采用的8.3命名规则只支持最长3字符的扩展名，为了兼容采用了.jpg。也因历史习惯和兼容性的考虑，.jpg目前更流行。JPEG2000作为JPEG的升级版，其压缩率比JPEG高约30％左右，同时支持有损和无损压缩。<br>JPEG2000格式有一个极其重要的特征在于它能实现渐进传输，即先传输图像的轮廓，然后逐步传输数据，不断提高图像质量，让图像由朦胧到清晰显示。此外，JPEG2000还支持所谓的“感兴趣区域”特性，也就是可以任意指定影像上感兴趣区域的压缩质量；另外，JPEG2000还可以选择指定的部分先解压缩来加载到内存中。JPEG2000和JPEG相比优势明显，且向下兼容，因此可取代传统的JPEG格式。</li><li>WebP<br>WebP 是 Google 在 2010 年发布的图片格式，希望以更高的压缩率替代 JPEG。它用 VP8 视频帧内编码作为其算法基础，取得了不错的压缩效果。WebP支持有损和无损压缩、支持完整的透明通道、也支持多帧动画，并且没有版权问题，是一种非常理想的图片格式。WebP支持动图，基本取代gif。<br>WebP不仅集成了PNG、JPEG和Gif的所有功能，而且相同质量的无损压缩WebP图片体积比PNG小大约26%；如果是有损压缩，相同质量的WebP图片体积比JPEG小25%-34%。<br>很多人会认为，既然WebP功能完善、压缩率更高，那直接用WebP取代上述所有的图片压缩格式不就行了吗？其实不然，WebP也有其缺点：我们知道JPEG是有损压缩而PNG是无损压缩，所以JPEG的压缩率高于PNG；但是有损压缩的算法决定了其压缩时间一定是高于无损压缩的，也就是说JPEG的压缩时间高于PNG。而WebP无论是无损还是有损压缩，压缩率都分别高于PNG和JPEG；与其相对应的是其压缩时间也比它们长的多。经测试，WebP图片的编码时间比JPEG长8倍。可以看出，时间和空间是一对矛盾；如果想要节省更多的空间，必然要付出额外的时间；如果想要节省时间，那么必然要付出空间的代价。这取决于我们在实际中对于时空不同的需求程度来做出选择。<br>不管怎么说，WebP还是一种强大的、理想的图片压缩格式，并且借由 Google 在网络世界的影响力，WebP 在几年的时间内已经得到了广泛的应用。看看你手机里的 App：微博、微信、QQ、淘宝等等，每个 App 里都有 WebP 的身影。<br>另外，WebP是Android4.0才引入的一种图片压缩格式，如果想要在Android4.0以前的版本支持WebP格式的图片，那么需要借助于第三方库来支持WebP格式图片，例如：<a href="https://github.com/alexey-pelykh/webp-android-backport" target="_blank" rel="noopener">webp-android-backport</a>函数库，当然考虑到一般的Android开发中只需要向下兼容到Android4.0即可，所以也可以忽略这个问题。</li></ul><p>目前来说，以上所述的五种格式，Android操作系统都提供了原生支持；但是在上层能直接调用的编码方式只有 JPEG、PNG、WebP 这三种。具体的，可以查看Bitmap类的枚举内部类CompressFormat类的枚举值来获取上层能调用的图片编码方式。你会发现枚举值也是JPEG、PNG和WEBP三种。<br>如果我们想要在应用层使用Gif格式图片，需要自行引入第三方函数库来提供对Gif格式图片的支持。不过一般我们用WebP取代Gif。</p></blockquote><h2 id="如何压缩"><a href="#如何压缩" class="headerlink" title="如何压缩"></a>如何压缩</h2><h3 id="压缩分类"><a href="#压缩分类" class="headerlink" title="压缩分类"></a>压缩分类</h3><h4 id="有损压缩"><a href="#有损压缩" class="headerlink" title="有损压缩"></a>有损压缩</h4><blockquote><p>有损压缩的基本依据是：人的眼睛对光线的敏感度远高于对颜色的敏感度，光线对景物的作用比颜色的作用更为重要。有损压缩的原理是：保持颜色的逐渐变化，删除图像中颜色的突然变化。生物学中的大量实验证明，人类大脑会自发地利用与附近最接近的颜色来填补所丢失的颜色。有损压缩的具体实现方法就是删除图像中景物边缘的某些颜色部分。当在屏幕上看这幅图时，大脑会利用在景物上看到的颜色填补所丢失的颜色部分。利用有损压缩技术，某些数据被有意地删除了，并且在图片重新加载至内存中时这些数据也不会还原，因此被称为是“有损”的。有损压缩技术可以灵活地设置压缩率。<br>无可否认，利用有损压缩技术可以在位图持久化存储的过程中大大地压缩图片的存储大小，但是会影响图像质量，这一点在压缩率很高时尤其明显。所以需要选择恰当的压缩率。</p></blockquote><h4 id="无损压缩"><a href="#无损压缩" class="headerlink" title="无损压缩"></a>无损压缩</h4><blockquote><p>无损压缩的基本原理是：相同的颜色信息只需保存一次。具体过程是：首先会确定图像中哪些区域是相同的，哪些是不同的。包括了重复数据的区域就可以被压缩，只需要记录该区域的起始点即可。<br>从本质上看，无损压缩的方法通过删除一些重复数据，也能在位图持久化存储的过程中减少要在磁盘上保存的图片大小。但是，如果将该图片重新读取到内存中，重复数据会被还原。因此，无损压缩的方法并不能减少图片的内存占用量，如果要减少图片占用内存的容量，就必须使用有损压缩方法。<br>无损压缩方法的优点是能够比较好地保存图像的质量，但是相对来说这种方法的压缩率比较低。<br>对比分析：有损压缩压缩率高而且可以灵活设置压缩率，并且删除的数据不可还原，因此可以减少图片的内存占用，但是对图片质量会有一定程度的影响；无损压缩可以很好地保存图片质量，也能保证一定的压缩率虽然没有有损压缩那么高，并且无损压缩删除的数据在重新加载至内存时会被还原，因此不可以减少图片的内存占用。</p></blockquote><h3 id="Android中压缩"><a href="#Android中压缩" class="headerlink" title="Android中压缩"></a>Android中压缩</h3><h4 id="编译时压缩"><a href="#编译时压缩" class="headerlink" title="编译时压缩"></a>编译时压缩</h4><p>AAPT打包时默认对PNG进行三个优化检查（<a href="http://androidxref.com/" target="_blank" rel="noopener">Android源码</a>中搜索analyze_image），默认使用的是libpng库进行无损压缩（修改色彩模式）：</p><ol><li>每个像素都是 R == G == B (grayscale 灰度)</li><li>每个像素都是 A == 255 (opaque 全透明)</li><li>是否不超过256种不同的RGBA颜色</li></ol><p>判断它是否可以被转成灰度格式的图片，判断它是否是全透明的，或判断它是否可以被转成一张索引图。</p><p>如果想压缩地更多，禁用掉AAPT的默认压缩PNG（一般二次压缩反而会增大体积），采用第三方压缩工具来提升压缩效果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">        buildTypes &#123;</span><br><span class="line">            release &#123;</span><br><span class="line">                &#x2F;&#x2F; Disables PNG crunching for the release build type.</span><br><span class="line">                crunchPngs false</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; If you&#39;re using an older version (Android Gradle plugin &lt; 3.0.0) of the plugin, use the</span><br><span class="line">    &#x2F;&#x2F; following:</span><br><span class="line">    &#x2F;&#x2F;  aaptOptions &#123;</span><br><span class="line">    &#x2F;&#x2F;      cruncherEnabled false</span><br><span class="line">    &#x2F;&#x2F;  &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>第三方工具：</p><ul><li><a href="https://imageoptim.com" target="_blank" rel="noopener">ImageOptim</a> 无损压缩</li><li><a href="https://pngmini.com" target="_blank" rel="noopener">ImageAlpha</a> 有损压缩</li><li><a href="https://tinypng.com" target="_blank" rel="noopener">TinyPNG</a> 有损压缩</li><li><a href="https://pngquant.org/" target="_blank" rel="noopener">Pngquant</a> 有损压缩</li><li><a href="http://advsys.net/ken/utils.htm" target="_blank" rel="noopener">Pngout</a> 无损压缩</li><li><a href="http://optipng.sourceforge.net/" target="_blank" rel="noopener">OptiPNG</a> 无损压缩</li></ul><h4 id="运行时压缩"><a href="#运行时压缩" class="headerlink" title="运行时压缩"></a>运行时压缩</h4><h5 id="质量压缩"><a href="#质量压缩" class="headerlink" title="质量压缩"></a>质量压缩</h5><p>质量压缩在不改变像素的大小的前提下，降低图像的质量（改变图片的位深及透明度等），从而降低存储大小，进而达到压缩的目的。</p><p><strong>质量压缩对内存大小占用无影响。</strong></p><blockquote><p>位深度指的是存储每个像素所用的位数，主要用于存储。<br>色深指的是每一个像素点用多少bit存储颜色，属于图片自身的一种属性。<br>位深一般小于或等于色深。<br>举个例子：某张图片100像素*100像素 色深32位(ARGB_8888)，保存时位深度为24位，那么：<br>该图片在内存中所占大小为：100 x 100 x (32 / 8) Byte<br>在文件中所占大小为 100 x 100 x ( 24/ 8 ) x 压缩率 Byte</p></blockquote><p>Android中的质量压缩API ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public boolean compress(CompressFormat format, int quality, OutputStream stream)</span><br></pre></td></tr></table></figure><p>Java 层函数 → Native 函数 → Skia函数 → 对应第三库函数（例如 libjpeg、libpng、libjwebp）</p><ul><li>CompressFormat format：压缩格式,它有JPEG、PNG、WEBP三种选择，JPEG是有损压缩，PNG是无损压缩，WEBP是Google推出的图像格式.</li><li>int quality：0~100可选，数值越大，质量越高，图像越大。</li><li>OutputStream stream：压缩后图像的输出流。</li></ul><p>针对JPEG的压缩库：</p><ul><li><a href="https://github.com/libjpeg-turbo/libjpeg-turbo" target="_blank" rel="noopener">libjpeg-turbo</a></li></ul><blockquote><p>libjpeg-turbo是用于x86和x86-64处理器的libjpeg的高速版本，它使用SIMD指令（MMX，SSE2等）来加速基线JPEG压缩和解压缩。 libjpeg-turbo的速度通常是未修改版本的libjpeg的2-4倍，其他所有条件都相同（对于非灰度JPEG压缩和解压缩，libjpeg-turbo的速度是libjpeg v6b的1.8倍至4.5倍）。</p></blockquote><ul><li><a href="https://github.com/mozilla/mozjpeg" target="_blank" rel="noopener">mozilla/mozjpeg</a></li></ul><blockquote><p>基于libjpeg-turbo，依靠三种技术（渐进JPEG编码，jpgcrush和网格量化）来减小JPEG图像的大小。libjpeg-turbo支持渐进式JPEG，但不支持jpgcrush和网格量化。mozjpeg的唯一目的是减少网络上提供的JPEG文件的大小，因此它牺牲了一些性能为代价。</p></blockquote><h5 id="尺寸压缩"><a href="#尺寸压缩" class="headerlink" title="尺寸压缩"></a>尺寸压缩</h5><p>尺寸压缩即减少图片长宽，或者说减少像素点，又称采样压缩（上采样为放大，下采样缩小，因此采样压缩为下采样）。</p><h6 id="邻近采样"><a href="#邻近采样" class="headerlink" title="邻近采样"></a>邻近采样</h6><p>邻近采样（Nearest Neighbour Resampling）采用邻近点插值算法，用一个像素点代替邻近的像素点。</p><p><a href="https://developer.android.com/topic/performance/graphics/load-bitmap?hl=zh-cn" target="_blank" rel="noopener">官方高效加载Bitmap指南</a>采用的方式就是进行邻近采样。</p><p>做法是先将 BitmapFactory.Options 中的 inJustDecodeBounds 设置为true，这样 BitmapFactory 在 decode 的时候能避免内存分配，但能对 outWidth，outHeight 和 outMimeType 赋值。然后通过获取到的outWidth，outHeight 以及 加载的目标宽高计算出合适的采样率赋值给 BitmapFactory.Options 中的 inSamleSize。最后 BitmapFactory.Options 中的 inJustDecodeBounds 设置回false，并进行相应的decode。</p><p>关键之处就是计算出合适的采样率，对应 BitmapFactory.Options 中的 inSamleSize（inSamleSize会是四舍五入后最接近2的幂的值）。<br>关于如何计算出合适的采样率，普遍的算法是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculateInSampleSize</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            BitmapFactory.Options options, <span class="keyword">int</span> reqWidth, <span class="keyword">int</span> reqHeight)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Raw height and width of image</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> height = options.outHeight;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> width = options.outWidth;</span><br><span class="line">    <span class="keyword">int</span> inSampleSize = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (height &gt; reqHeight || width &gt; reqWidth) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> halfHeight = height / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> halfWidth = width / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Calculate the largest inSampleSize value that is a power of 2 and keeps both</span></span><br><span class="line">        <span class="comment">// height and width larger than the requested height and width.</span></span><br><span class="line">        <span class="keyword">while</span> ((halfHeight / inSampleSize) &gt;= reqHeight</span><br><span class="line">                &amp;&amp; (halfWidth / inSampleSize) &gt;= reqWidth) &#123;</span><br><span class="line">            inSampleSize *= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> inSampleSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>第三个开源库<a href="https://github.com/Curzibn/Luban" target="_blank" rel="noopener">Luban</a>的<a href="https://github.com/Curzibn/Luban/blob/master/DESCRIPTION.md" target="_blank" rel="noopener">计算采样率算法思路</a></p></blockquote><h6 id="双线性采样"><a href="#双线性采样" class="headerlink" title="双线性采样"></a>双线性采样</h6><p>双线性采样（Bilinear Resampling）采用双线性插值算法，相比邻近采样简单粗暴的选择一个像素点代替其他像素点，双线性采样参考源像素相应位置周围2x2个点的值，根据相对位置取对应的权重，经过计算得到目标图像。</p><p>Android中双线性采样有两个API：</p><ul><li>public static Bitmap createScaledBitmap(@NonNull Bitmap src, int dstWidth, int dstHeight, boolean filter)</li><li>public static Bitmap createBitmap(@NonNull Bitmap source, int x, int y, int width, int height, @Nullable Matrix m, boolean filter)</li></ul><p>事实上，createScaledBitmap(@NonNull Bitmap src, int dstWidth, int dstHeight, boolean filter) 方法最终也是调用 createBitmap(@NonNull Bitmap source, int x, int y, int width, int height, @Nullable Matrix m, boolean filter) 方法。</p><ul><li>Bitmap source：源图像</li><li>int x：目标图像第一个像素的x坐标</li><li>int y：目标图像第一个像素的y坐标</li><li>int width：目标图像的宽度（像素点个数）</li><li>int height：目标图像的高度（像素点个数）</li><li>Matrix m：变换矩阵</li><li>boolean filter：是否开启双线性滤波</li></ul><h6 id="双立方-双三次采样"><a href="#双立方-双三次采样" class="headerlink" title="双立方/双三次采样"></a>双立方/双三次采样</h6><p><a href="https://en.wikipedia.org/wiki/Bicubic_interpolation" target="_blank" rel="noopener">双立方/双三次采样（Bicubic Resampling）</a>，邻近点插值算法的目标像素值由源图上单个像素决定，双线性內插值算法由源像素某点周围 2x2 个像素点按一定权重获得，而双立方／双三次插值算法更进一步参考了源像素某点周围 4x4 个像素。</p><p>Android中对于双立方/双三次采样没有支持，可以通过手动编写算法或者引用第三方算法库，幸运的是这个算法在 ffmpeg 中已经给到了支持，具体的实现在 libswscale/swscale.c 文件中：<a href="http://www.ffmpeg.org/ffmpeg-scaler.html" target="_blank" rel="noopener">FFmpeg Scaler Documentation</a>。</p><h6 id="Lanczos-采样"><a href="#Lanczos-采样" class="headerlink" title="Lanczos 采样"></a>Lanczos 采样</h6><p><a href="https://en.wikipedia.org/wiki/Lanczos_resampling" target="_blank" rel="noopener">Lanczos 采样</a>和 Lanczos 过滤是 Lanczos 算法的两种常见应用，它可以用作低通滤波器或者用于平滑地在采样之间插入数字信号，Lanczos 采样一般用来增加数字信号的采样率，或者间隔采样来降低采样率。<br>Lanczos 采样使用的 Lanczos 算法也可以用来作为图片的缩放，Lanczos 算法和双三次插值算法都是使用卷积核来通过输入像素计算输出像素。<br>同样的，Lanczos 算法在 ffmpeg 的 libswscale/swscale.c 中也有实现。其实不光 Lanczos 和上面的三种算法，ffmpeg 还提供了其他的图像重采样方法，诸如 area averaging、Gaussian 等等。</p><h5 id="色彩模式压缩"><a href="#色彩模式压缩" class="headerlink" title="色彩模式压缩"></a>色彩模式压缩</h5><p>BitmapFactory.Options中inPreferredConfig可以指定色彩模式，采用色位更少的色彩模式。</p><hr><p>参考链接：</p><ul><li><a href="https://yunxi.vkucloud.com/article/e53f10f5-0f45-41a3-45dd-08d6f1abedd9" target="_blank" rel="noopener">Android Bitmap（位图）详解</a></li><li><a href="https://juejin.im/entry/5ad0213f6fb9a028df2306cd" target="_blank" rel="noopener">Android中Bitmap内存优化</a></li><li><a href="https://juejin.im/entry/58fc75e0ac502e0063aa433b" target="_blank" rel="noopener">也谈图片压缩</a></li><li><a href="https://juejin.im/post/5a1bd6595188254cc067981f" target="_blank" rel="noopener">Android平台图像压缩方案</a></li><li>QQ音乐技术文章<a href="https://cloud.tencent.com/developer/article/1006307" target="_blank" rel="noopener">Android 中图片压缩分析（上）</a></li><li>QQ音乐技术文章<a href="https://cloud.tencent.com/developer/article/1006352" target="_blank" rel="noopener">Android 中图片压缩分析（下）</a></li><li><a href="https://juejin.im/post/58c3b29761ff4b005d906730#heading-14" target="_blank" rel="noopener">Android 性能优化（五）之细说 Bitmap</a></li><li><a href="https://developer.android.com/topic/performance/graphics/load-bitmap.html" target="_blank" rel="noopener">Loading Large Bitmaps Efficiently</a></li><li><a href="https://developer.android.google.cn/topic/performance/graphics/cache-bitmap.html" target="_blank" rel="noopener">Caching Bitmaps</a></li><li><a href="https://developer.android.com/topic/performance/graphics/manage-memory" target="_blank" rel="noopener">Managing Bitmap Memory</a></li><li><a href="https://developer.android.com/topic/performance/graphics" target="_blank" rel="noopener">Handling bitmaps</a></li></ul><p>后记：可研读核心类Bitmap、BitmapFactory。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;为什么要压缩&quot;&gt;&lt;a href=&quot;#为什么要压缩&quot; class=&quot;headerlink&quot; title=&quot;为什么要压缩&quot;&gt;&lt;/a&gt;为什么要压缩&lt;/h2&gt;&lt;h3 id=&quot;减少内存占用&quot;&gt;&lt;a href=&quot;#减少内存占用&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
      <category term="Android" scheme="https://codepoem.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="https://codepoem.github.io/tags/Android/"/>
    
      <category term="图片" scheme="https://codepoem.github.io/tags/%E5%9B%BE%E7%89%87/"/>
    
      <category term="压缩" scheme="https://codepoem.github.io/tags/%E5%8E%8B%E7%BC%A9/"/>
    
  </entry>
  
  <entry>
    <title>模板整理之上传仓库</title>
    <link href="https://codepoem.github.io/2019/10/09/%E6%A8%A1%E6%9D%BF%E6%95%B4%E7%90%86%E4%B9%8B%E4%B8%8A%E4%BC%A0%E4%BB%93%E5%BA%93/"/>
    <id>https://codepoem.github.io/2019/10/09/模板整理之上传仓库/</id>
    <published>2019-10-09T09:19:33.000Z</published>
    <updated>2019-10-09T09:19:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>我们在日常打aar包和jar包，并上传到远端中央仓库时，需要引入大段gradle代码，较为繁琐。<br>我这里整理了常用的上传到中央仓库的gradle代码，提供了较为方便的使用方式。<a href="">上传代码模板GitHub</a><br>目前只有上传到bintray也就是jcenter的整理，后期有需要其他远端中央仓库的会继续跟进。</p><hr><ul><li>模板整理<a href="https://github.com/CodePoem/VTemplate" target="_blank" rel="noopener">GitHub</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我们在日常打aar包和jar包，并上传到远端中央仓库时，需要引入大段gradle代码，较为繁琐。&lt;br&gt;我这里整理了常用的上传到中央仓库的gradle代码，提供了较为方便的使用方式。&lt;a href=&quot;&quot;&gt;上传代码模板GitHub&lt;/a&gt;&lt;br&gt;目前只有上传到bintray也
      
    
    </summary>
    
      <category term="模板" scheme="https://codepoem.github.io/categories/%E6%A8%A1%E6%9D%BF/"/>
    
    
      <category term="Android" scheme="https://codepoem.github.io/tags/Android/"/>
    
      <category term="模板" scheme="https://codepoem.github.io/tags/%E6%A8%A1%E6%9D%BF/"/>
    
      <category term="上传仓库" scheme="https://codepoem.github.io/tags/%E4%B8%8A%E4%BC%A0%E4%BB%93%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>模板整理之Travis CI</title>
    <link href="https://codepoem.github.io/2019/10/09/%E6%A8%A1%E6%9D%BF%E6%95%B4%E7%90%86%E4%B9%8BTravis%20CI/"/>
    <id>https://codepoem.github.io/2019/10/09/模板整理之Travis CI/</id>
    <published>2019-10-09T08:54:30.000Z</published>
    <updated>2019-10-09T08:54:33.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://docs.travis-ci.com/" target="_blank" rel="noopener">官方文档</a></p><p>免费Travis-CI（针对开源项目）：<a href="https://travis-ci.org" target="_blank" rel="noopener">https://travis-ci.org</a></p><p>收费Travis-CI（针对私有和商业项目）：<a href="https://travis-ci.com" target="_blank" rel="noopener">https://travis-ci.com</a></p><h2 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h2><ol><li>登录 Travis CI 并对指定的项目启用。</li><li>配置 .travis.yml ，参考官方文档。</li><li>push（或其他方式）触发Travis-CI。</li></ol><h2 id="实现工作流"><a href="#实现工作流" class="headerlink" title="实现工作流"></a>实现工作流</h2><ol><li>构建。开发一些新功能，提交代码后自动构建出一个APK（可以是测试版，也可以是发布版）。</li><li>部署。将 APK 上传到 Github Release / <a href="https://fir.im/" target="_blank" rel="noopener">Fir.im</a> / <a href="https://www.pgyer.com/" target="_blank" rel="noopener">蒲公英</a>等。</li><li>通知。发出通知（邮件、消息等形式）。</li></ol><h3 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h3><h4 id="release签名证书安全"><a href="#release签名证书安全" class="headerlink" title="release签名证书安全"></a>release签名证书安全</h4><p>Android 项目发布需要证书文件、密码、别名、别名密码。无论是开源项目还是私有项目，任何时候都不应该将原始证书或密码放入代码库（原则上来讲证书和密码也不应该交于开发人员，而应该只能通过发布服务器进行编译）</p><p>Travis CI 为此提供了 2 种解决方案：</p><ol><li>对敏感信息、密码、证书等进行对称加密，在 CI 构建环境时解密。</li><li>将密码等通过 Travis CI 控制台设置为构建时的环境变量。</li></ol><p>个人倾向使用第二种方案，但 Travis CI 控制台无法上传文件，因此涉及到文件加密的部分，选择第一种方案。</p><h5 id="加密证书文件："><a href="#加密证书文件：" class="headerlink" title="加密证书文件："></a>加密证书文件：</h5><ol><li>本地安装 Travis CLI 命令行工具。</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gem install travis</span><br></pre></td></tr></table></figure><p>这一步如果遇到错误, 尝试加sudo，请升级一下 ruby 版本。</p><ol start="2"><li>命令行登录 Travis（第一次登录才要），并输入 GitHub 的用户名和密码。</li></ol><p>针对免费版 <a href="https://travis-ci.org：">https://travis-ci.org：</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">travis login --org</span><br></pre></td></tr></table></figure><p>针对收费版Travis-C <a href="https://travis-ci.com：">https://travis-ci.com：</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">travis login --pro</span><br></pre></td></tr></table></figure><p>这一步如果遇到travis命令找不到, 尝试找到travis安装的bin目录，并配置上环境变量。</p><ol start="3"><li>进入项目根目录，加密证书。</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">travis encrypt-file XXX.jks --add</span><br></pre></td></tr></table></figure><p>命令执行结果：</p><ol><li>在 Travis CI 控制台自动生成一对秘钥。</li><li>基于秘钥通过 openssl 对文件进行加密，并在根目录生成 XXX.jks.enc 文件。</li><li>在 .travis.yml 中自动生成 Travis CI 环境下解密文件的配置。</li></ol><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">before_install:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">openssl</span> <span class="string">aes-256-cbc</span> <span class="string">-K</span> <span class="string">$encrypted_cd91ae131fae_key</span> <span class="string">-iv</span> <span class="string">$encrypted_cd91ae131fae_iv</span></span><br><span class="line">    <span class="string">-in</span> <span class="string">mrd@vdreamers.enc</span> <span class="string">-out</span> <span class="string">mrd@vdreamers</span> <span class="string">-d</span></span><br></pre></td></tr></table></figure><h5 id="加密证书密码"><a href="#加密证书密码" class="headerlink" title="加密证书密码"></a>加密证书密码</h5><p>在Travis CI控制台配置证书密码、证书别名、证书别名密码三个环境变量（KEYSTORE_PWD、KEYSTORE_ALIAS、KEYSTORE_ALIAS_PWD）。</p><h5 id="实现本地和Travis-CI构建release包互不干扰"><a href="#实现本地和Travis-CI构建release包互不干扰" class="headerlink" title="实现本地和Travis-CI构建release包互不干扰"></a>实现本地和Travis-CI构建release包互不干扰</h5><p>基本思路，判断环境变量 CI 是否 为 true，通过 System.getenv(“CI”) 去获取环境变量 CI 的值，fals e即为本地构建，true 即为 Travis-CI 构建。<br>本地构建去 local.properties 中读取证书配置；Travis-CI 构建通过 System.getenv 去读取环境变量的证书配置。</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: <span class="string">'com.android.application'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> keystorePWD = <span class="string">''</span></span><br><span class="line"><span class="keyword">def</span> keystoreAlias = <span class="string">''</span></span><br><span class="line"><span class="keyword">def</span> keystoreAliasPWD = <span class="string">''</span></span><br><span class="line"><span class="comment">// local.properties file in the root director</span></span><br><span class="line"><span class="keyword">def</span> keyFile = <span class="keyword">project</span>.rootProject.<span class="keyword">file</span>(<span class="string">'local.properties'</span>)</span><br><span class="line"></span><br><span class="line">Properties properties = <span class="keyword">new</span> Properties()</span><br><span class="line"><span class="comment">// local.properties exists</span></span><br><span class="line"><span class="keyword">if</span> (keyFile.exists()) &#123;</span><br><span class="line">    properties.load(keyFile.newDataInputStream())</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    keyFile = <span class="keyword">file</span>(<span class="string">"../no_exists_keystore.tmp"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// local.properties contains keystore.path</span></span><br><span class="line"><span class="keyword">if</span> (properties.containsKey(<span class="string">"keystore.path"</span>)) &#123;</span><br><span class="line">    keyFile = <span class="keyword">file</span>(properties.getProperty(<span class="string">"keystore.path"</span>))</span><br><span class="line">    keystorePWD = properties.getProperty(<span class="string">"keystore.password"</span>)</span><br><span class="line">    keystoreAlias = properties.getProperty(<span class="string">"keystore.alias"</span>)</span><br><span class="line">    keystoreAliasPWD = properties.getProperty(<span class="string">"keystore.alias_password"</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    keyFile = <span class="keyword">file</span>(<span class="string">"../no_exists_keystore.tmp"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> isRunningOnTravis = System.getenv(<span class="string">"CI"</span>) == <span class="string">"true"</span></span><br><span class="line"><span class="keyword">if</span> (isRunningOnTravis) &#123;</span><br><span class="line">    keyFile = <span class="keyword">file</span>(<span class="string">"../mrd@vdreamers"</span>)</span><br><span class="line">    keystorePWD = System.getenv(<span class="string">"KEYSTORE_PWD"</span>)</span><br><span class="line">    keystoreAlias = System.getenv(<span class="string">"KEYSTORE_ALIAS"</span>)</span><br><span class="line">    keystoreAliasPWD = System.getenv(<span class="string">"KEYSTORE_ALIAS_PWD"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">android &#123;</span><br><span class="line">    signingConfigs &#123;</span><br><span class="line">        release &#123;</span><br><span class="line">            keyAlias keystoreAlias</span><br><span class="line">            keyPassword keystoreAliasPWD</span><br><span class="line">            storeFile keyFile</span><br><span class="line">            storePassword keystorePWD</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    buildTypes &#123;</span><br><span class="line">        debug &#123;</span><br><span class="line">            minifyEnabled <span class="keyword">false</span></span><br><span class="line">            proguardFiles getDefaultProguardFile(<span class="string">'proguard-android-optimize.txt'</span>), <span class="string">'proguard-rules.pro'</span></span><br><span class="line">            signingConfig signingConfigs.debug</span><br><span class="line">        &#125;</span><br><span class="line">        release &#123;</span><br><span class="line">            minifyEnabled <span class="keyword">false</span></span><br><span class="line">            proguardFiles getDefaultProguardFile(<span class="string">'proguard-android-optimize.txt'</span>), <span class="string">'proguard-rules.pro'</span></span><br><span class="line">            <span class="keyword">if</span> (keyFile.exists() || isRunningOnTravis) &#123;</span><br><span class="line">                <span class="keyword">println</span>(<span class="string">"WITH -&gt; buildTypes -&gt; release: using jks key"</span>)</span><br><span class="line">                signingConfig signingConfigs.release</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">println</span>(<span class="string">"WITH -&gt; buildTypes -&gt; release: using default key"</span>)</span><br><span class="line">                signingConfig signingConfigs.debug</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本地构建需要在本地local.properties中配置好证书路径keystore.path、证书密码keystore.password、证书别名keystore.alias、证书别名密码keystore.alias_password；<br>分别对应着Travis CI控制台加密的证书秘钥对和环境变量证书密码KEYSTORE_PWD、证书别名KEYSTORE_ALIAS、证书别名密码KEYSTORE_ALIAS_PWD。</p><h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><h4 id="GitHub-Release"><a href="#GitHub-Release" class="headerlink" title="GitHub Release"></a>GitHub Release</h4><ol><li>命令行自动生成 deploy 配置。</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">travis setup releases</span><br></pre></td></tr></table></figure><p>需要输入 GitHub 账户名和密码以及 apk 路径，如 app/build/outputs/apk/app-release.apk<br>执行完后会自动在 .travis.yml 添加如下配置：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">provider:</span> <span class="string">releases</span></span><br><span class="line">  <span class="attr">api_key:</span></span><br><span class="line">    <span class="attr">secure:</span> <span class="string">qOr4mGdf8lESDCiMo7ZJbGqLEHI3cXuV4UlQ2ZzvjSpDQyXrQ2l8wHMdgTkFxmlJWReOUuumHK346StBlGA2mQ5ufc6LhtHaCJWNpnk2Nixd2qFma9ySgPakz+7NoMml4wvkgMnn4HBCTV13ucJPxEzVt8KkX1JAiN9s5rh8SkB36i9KC4i/SuAPNPx2vHbglnoPFtToBlQa+cMLRSlXVkLHYYVdWRZOBRneu/H79oPkw5ajfsSG5u7RCCcEaaAfY1oU7ho1mrB1Kogq64BemGZSkIHgF5TCmmWgNypDlAm92tCN0G3uP0xffUZZsUqYoHiflXTjyXoYG4gXXC+SCCmkkFah0DZPcTZ6AHerBJ/8YgJX6/8tV3sH89PuM6HEuPmHbE3xEsGzUZWNrkJWHdJBLi5bXZnuSRvq+JDM/0CYSYuTx+lHCcCUiODIKTXFwHOaB+J+bKUTvvz91Rd7ELodUiBTAI/hXDYmWBAgY9Snw8+qBXiA7Ocp+ykcRuiUXXxvYlLgIzqtTEnoODBOsZ5ukjJoUs2GObcOgyBt4eedv7EfUcUKxHdf7ECZbhCEvhtVvHGzzIN5BN3R8+YJKnb0CmsO6FyCgCSnTyvKlFVfSX5s0v9E7XVFrCOo1gVDoL28v7AmrDZsl1mEaRSvVcOHtAXEhZEyF0CdafJ6s5A=</span></span><br><span class="line">  <span class="attr">file:</span> <span class="string">app/build/outputs/apk/app-release.apk</span></span><br><span class="line">  <span class="comment"># 这句手动添加</span></span><br><span class="line">  <span class="attr">skip_cleanup:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">on:</span></span><br><span class="line">    <span class="attr">repo:</span> <span class="string">CodePoem/VTemplate</span></span><br><span class="line">    <span class="comment"># 这句手动添加</span></span><br><span class="line">    <span class="attr">tags:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><ul><li>provider：发布目标为 GitHub Release ，除了 GitHub 外，Travis CI还支持发布到 AWS 、Google App Engine 等数十种 provider 。</li><li>secure：是加密后的 GitHub Access Token 。</li><li>file：发布的文件。</li><li>skip_cleanup：默认情况下 Travis CI 在完成编译后会清除所有生成的文件，因此要将 skip_cleanup 设置为 true 来忽略此操作。</li><li>on：发布的时机，这里配置为 tags : true，即只在有 tag 的情况才发布。</li></ul><ol start="2"><li>打 Tag 后 Push 代码触发 CI 。</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git tag -a v0.0.1-alpha-1 -m "这里是Tag注释，说清楚这个版本的主要改动，也可以省略-m参数直接写长文本"</span><br><span class="line">git push origin --tags</span><br></pre></td></tr></table></figure><h4 id="Fir-im"><a href="#Fir-im" class="headerlink" title="Fir.im"></a><a href="https://fir.im/" target="_blank" rel="noopener">Fir.im</a></h4><ol><li>登录 Fir.im 获取 API Token 。</li><li>将获取的 API Toke n配置到 Travis CI 的环境变量 FIR_API_TOKEN。</li><li>添加配置。</li></ol><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">before_install:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">gem</span> <span class="string">install</span> <span class="string">fir-cli</span></span><br><span class="line"><span class="attr">after_deploy:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">fir</span> <span class="string">p</span> <span class="string">app/build/outputs/apk/release/app-release.apk</span> <span class="string">-T</span> <span class="string">$FIR_API_TOKEN</span> <span class="string">-c</span> <span class="string">"`git cat-file tag $TRAVIS_TAG`"</span></span><br></pre></td></tr></table></figure><ol start="4"><li>打 Tag 后 Push 代码触发 CI 。</li></ol><h3 id="通知"><a href="#通知" class="headerlink" title="通知"></a>通知</h3><h4 id="SendCloud邮件通知"><a href="#SendCloud邮件通知" class="headerlink" title="SendCloud邮件通知"></a>SendCloud邮件通知</h4><ol><li>注册 SendCloud 。</li><li>创建触发式模板 update_template 。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">%TRAVIS_REPO_SLUG%新版本%TRAVIS_TAG%已经发布了，功能更新：</span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">%TAG_DESCRIPTION%</span><br><span class="line">   </span><br><span class="line">去下载：</span><br><span class="line">https:&#x2F;&#x2F;fir.im&#x2F;ep8s</span><br></pre></td></tr></table></figure><ol start="3"><li>添加配置，调用发送邮件 API 。</li></ol><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">after_deploy:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">curl</span> <span class="string">-d</span> <span class="string">"apiUser=******&amp;apiKey=******&amp;from=test@test.com&amp;fromName=testTitle&amp;subject=测试&amp;replyTo=test@test.com&amp;templateInvokeName=update_template"</span></span><br><span class="line">    <span class="string">--data-urlencode</span> <span class="string">"xsmtpapi=&#123;'to':['806957428@qq.com'],'sub':&#123;'%TRAVIS_REPO_SLUG%':['$TRAVIS_REPO_SLUG'],'%TRAVIS_TAG%':['$TRAVIS_TAG'],'%TAG_DESCRIPTION%':['$(git cat-file tag $TRAVIS_TAG)']&#125;&#125;"</span> <span class="string">http://api.sendcloud.net/apiv2/mail/sendtemplate</span></span><br></pre></td></tr></table></figure><ol start="4"><li>打 Tag 后 Push 代码触发 CI 。</li></ol><hr><ul><li>模板整理<a href="https://github.com/CodePoem/VTemplate" target="_blank" rel="noopener">GitHub</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://docs.travis-ci.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;官方文档&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;免费Travis-CI（针对开源项目）：&lt;a href=&quot;https://travis-ci.org&quot; 
      
    
    </summary>
    
      <category term="模板" scheme="https://codepoem.github.io/categories/%E6%A8%A1%E6%9D%BF/"/>
    
    
      <category term="Android" scheme="https://codepoem.github.io/tags/Android/"/>
    
      <category term="模板" scheme="https://codepoem.github.io/tags/%E6%A8%A1%E6%9D%BF/"/>
    
      <category term="Travis CI" scheme="https://codepoem.github.io/tags/Travis-CI/"/>
    
  </entry>
  
  <entry>
    <title>Crash治理之TimeoutException</title>
    <link href="https://codepoem.github.io/2019/09/25/Crash%E6%B2%BB%E7%90%86%E4%B9%8BTimeoutException/"/>
    <id>https://codepoem.github.io/2019/09/25/Crash治理之TimeoutException/</id>
    <published>2019-09-25T07:36:46.000Z</published>
    <updated>2019-09-25T07:36:49.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h2><p>与 GC 过程相关的守护线程中的2个守护线程 FinalizerDaemon 和 FinalizerWatchdogDaemon 有关。</p><ul><li>FinalizerDaemon ：析构守护线程。对于重写了成员函数 finalize 的对象，它们被 GC 决定回收时，并没有马上被回收，而是被放入到一个队列中，等待 FinalizerDaemon 守护线程去调用它们的成员函数 finalize ，然后再被回收。</li><li>FinalizerWatchdogDaemon ：析构监护守护线程。用来监控 FinalizerDaemon 线程的执行。一旦检测那些重定了成员函数 finalize 的对象在执行成员函数 finalize 时超出一定的时间，那么就会退出 VM 。</li></ul><p>原因小总结：</p><p>GC 过程中 FinalizerDaemon 守护线程执行 doFinalize 方法超时。FinalizerWatchdogDaemon检测到后产生 TimeoutException 并退出虚拟机。<br>（每个手机触发 Timeout 的时长不同，比如 vivo 的某些rom 是2分钟，模拟器统一都是10秒钟）</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="理想方案"><a href="#理想方案" class="headerlink" title="理想方案"></a>理想方案</h3><ol><li>减少对 finalize() 方法的依赖，尽量不依靠 finalize() 方法释放资源，手动处理资源释放逻辑；如果不得已使用 finalize() 方法，尽量减少耗时以及线程同步时间。</li><li>减少 finalizable 对象个数，即减少有 finalize() 方法的对象创建，降低 finalizable 对象 GC 次数；Android 5.0 以后 View 默认会实现finalize方法，那么减少View的创建就是一种解决方法。</li></ol><p>理想方案现实情况下却不太容易完全做到。往往需要采用止损方案。</p><h3 id="止损方案"><a href="#止损方案" class="headerlink" title="止损方案"></a>止损方案</h3><p>止损方案本质都是不检测该异常或忽略该异常、不上报该异常，治标不治本。</p><h4 id="尝试反射去关闭-FinalizerWatchdogDaemon"><a href="#尝试反射去关闭-FinalizerWatchdogDaemon" class="headerlink" title="尝试反射去关闭 FinalizerWatchdogDaemon"></a>尝试反射去关闭 FinalizerWatchdogDaemon</h4><p><strong>限制：</strong></p><p>Android 9.0 版本开始限制 Private API 调用，不能再使用反射调用 Daemons 以及 FinalizerWatchdogDaemon 类方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WatchDogKiller</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"WatchDogKiller"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> sWatchdogStopped = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">checkWatchDogAlive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Class clazz;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            clazz = Class.forName(<span class="string">"java.lang.Daemons$FinalizerWatchdogDaemon"</span>);</span><br><span class="line">            <span class="keyword">final</span> Field field = clazz.getDeclaredField(<span class="string">"INSTANCE"</span>);</span><br><span class="line">            field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">final</span> Object watchdog = field.get(<span class="keyword">null</span>);</span><br><span class="line">            Method isRunningMethod = clazz.getSuperclass().getDeclaredMethod(<span class="string">"isRunning"</span>);</span><br><span class="line">            isRunningMethod.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">boolean</span> isRunning = (<span class="keyword">boolean</span>) isRunningMethod.invoke(watchdog);</span><br><span class="line">            <span class="keyword">return</span> isRunning;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">stopWatchDog</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 建议在在debug包或者灰度包中不要stop，保留发现问题的能力。</span></span><br><span class="line">        <span class="keyword">if</span> (!BuildConfig.DEBUG) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Android P 以后不能反射FinalizerWatchdogDaemon</span></span><br><span class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">28</span>) &#123;</span><br><span class="line">            Log.w(TAG, <span class="string">"stopWatchDog, do not support after Android P, just return"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sWatchdogStopped) &#123;</span><br><span class="line">            Log.w(TAG, <span class="string">"stopWatchDog, already stopped, just return"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sWatchdogStopped = <span class="keyword">true</span>;</span><br><span class="line">        Log.w(TAG, <span class="string">"stopWatchDog, try to stop watchdog"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> Class clazz = Class.forName(<span class="string">"java.lang.Daemons$FinalizerWatchdogDaemon"</span>);</span><br><span class="line">            <span class="keyword">final</span> Field field = clazz.getDeclaredField(<span class="string">"INSTANCE"</span>);</span><br><span class="line">            field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">final</span> Object watchdog = field.get(<span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">final</span> Field thread = clazz.getSuperclass().getDeclaredField(<span class="string">"thread"</span>);</span><br><span class="line">                thread.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                thread.set(watchdog, <span class="keyword">null</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> Throwable t) &#123;</span><br><span class="line">                Log.e(TAG, <span class="string">"stopWatchDog, set null occur error:"</span> + t);</span><br><span class="line"></span><br><span class="line">                t.printStackTrace();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 直接调用stop方法，在Android 6.0之前会有线程安全问题</span></span><br><span class="line">                    <span class="keyword">final</span> Method method = clazz.getSuperclass().getDeclaredMethod(<span class="string">"stop"</span>);</span><br><span class="line">                    method.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                    method.invoke(watchdog);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> Throwable e) &#123;</span><br><span class="line">                    Log.e(TAG, <span class="string">"stopWatchDog, stop occur error:"</span> + t);</span><br><span class="line">                    t.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> Throwable t) &#123;</span><br><span class="line">            Log.e(TAG, <span class="string">"stopWatchDog, get object occur error:"</span> + t);</span><br><span class="line">            t.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SampleApplication</span> <span class="keyword">extends</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">attachBaseContext</span><span class="params">(Context base)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.attachBaseContext(base);</span><br><span class="line">        WatchDogKiller.stopWatchDog();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="利用-Thread-UncaughtExceptionHandler-阻断-TimeoutException-处理"><a href="#利用-Thread-UncaughtExceptionHandler-阻断-TimeoutException-处理" class="headerlink" title="利用 Thread.UncaughtExceptionHandler 阻断 TimeoutException 处理"></a>利用 Thread.UncaughtExceptionHandler 阻断 TimeoutException 处理</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SampleApplication</span> <span class="keyword">extends</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate();</span><br><span class="line">        <span class="keyword">final</span> Thread.UncaughtExceptionHandler defaultUncaughtExceptionHandler =</span><br><span class="line">                Thread.getDefaultUncaughtExceptionHandler();</span><br><span class="line">        Thread.setDefaultUncaughtExceptionHandler(<span class="keyword">new</span> Thread.UncaughtExceptionHandler() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">uncaughtException</span><span class="params">(Thread t, Throwable e)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (t.getName().equals(<span class="string">"FinalizerWatchdogDaemon"</span>) &amp;&amp; e <span class="keyword">instanceof</span> TimeoutException) &#123;</span><br><span class="line">                    <span class="comment">// ignore it</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    defaultUncaughtExceptionHandler.uncaughtException(t, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><strong>推荐阅读:</strong></p><ol><li><a href="https://yq.aliyun.com/articles/225751" target="_blank" rel="noopener">提升Android下内存的使用意识和排查能力</a></li><li><a href="https://yq.aliyun.com/articles/225755" target="_blank" rel="noopener">再谈Finalizer对象–大型App中内存与性能的隐性杀手</a></li><li><a href="https://www.jianshu.com/p/18950c9b0ec9" target="_blank" rel="noopener">从Daemons到finalize timed out after 10 seconds</a></li><li><a href="https://blog.csdn.net/pbm863521/article/details/74451935" target="_blank" rel="noopener">ART运行时垃圾收集（GC）过程分析</a></li><li><a href="https://segmentfault.com/a/1190000019373275" target="_blank" rel="noopener">滴滴出行安卓端 finalize time out 的解决方案</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;产生原因&quot;&gt;&lt;a href=&quot;#产生原因&quot; class=&quot;headerlink&quot; title=&quot;产生原因&quot;&gt;&lt;/a&gt;产生原因&lt;/h2&gt;&lt;p&gt;与 GC 过程相关的守护线程中的2个守护线程 FinalizerDaemon 和 FinalizerWatchdogDaem
      
    
    </summary>
    
      <category term="Android" scheme="https://codepoem.github.io/categories/Android/"/>
    
    
      <category term="Crash" scheme="https://codepoem.github.io/tags/Crash/"/>
    
      <category term="TimeoutException" scheme="https://codepoem.github.io/tags/TimeoutException/"/>
    
  </entry>
  
  <entry>
    <title>Android动画</title>
    <link href="https://codepoem.github.io/2019/09/16/Android%E5%8A%A8%E7%94%BB/"/>
    <id>https://codepoem.github.io/2019/09/16/Android动画/</id>
    <published>2019-09-16T15:48:10.000Z</published>
    <updated>2019-09-16T15:48:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>Android中动画划分为两大类 视图动画（View Animation）和 属性动画（Property Animation）。其中 属性动画（Property Animation）需要在Android3.0之后（API &gt;= 11）使用。<br>视图动画（View Animation）又包括了 帧动画（Frame Animation） 和 补间动画（Tweened Animation）。</p><h2 id="视图动画（View-Animation）"><a href="#视图动画（View-Animation）" class="headerlink" title="视图动画（View Animation）"></a>视图动画（View Animation）</h2><h3 id="帧动画（Frame-Animation）"><a href="#帧动画（Frame-Animation）" class="headerlink" title="帧动画（Frame Animation）"></a>帧动画（Frame Animation）</h3><p>帧动画（Frame Animation） 有时也叫 Drawable动画，这种动画的实质其实是Drawable。像播放幻灯片一样，利用视觉残留产生动画效果。</p><p>核心类：AnimationDrawable</p><p>使用方式：</p><h4 id="XML定义帧动画"><a href="#XML定义帧动画" class="headerlink" title="XML定义帧动画"></a>XML定义帧动画</h4><p>推荐使用XML定义动画：</p><p>在res/drawable下新建animation_frame_test.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">animation-list</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:oneshot</span>=<span class="string">"false"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:drawable</span>=<span class="string">"@color/colorPrimary"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:duration</span>=<span class="string">"300"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:drawable</span>=<span class="string">"@color/colorPrimaryDark"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:duration</span>=<span class="string">"300"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">animation-list</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="Java代码创建帧动画"><a href="#Java代码创建帧动画" class="headerlink" title="Java代码创建帧动画"></a>Java代码创建帧动画</h4><p>创建AnimationDrawable对象，addFrame(Drawable frame,int duration)向动画中添加帧，调用start()和stop()。</p><h3 id="补间动画（Tweened-Animation）"><a href="#补间动画（Tweened-Animation）" class="headerlink" title="补间动画（Tweened Animation）"></a>补间动画（Tweened Animation）</h3><p>补间动画（Tweened Animation）只能应用于View对象，而且只支持一部分属性，它只是改变了View对象绘制的位置，而没有改变View对象本身（所以点击响应区域还在原来的位置）。多用于Window切换动画或Activity跳转动画。</p><p>核心类：android.view.animation.Animator</p><p>补间动画可以分为四种形式，分别是 alpha（淡入淡出），translate（位移），scale（缩放大小），rotate（旋转）。</p><h4 id="java类"><a href="#java类" class="headerlink" title="java类"></a>java类</h4><ul><li>AlphaAnimation 渐变透明度动画效果</li><li>RotateAnimation 画面转移旋转动画效果</li><li>ScaleAnimation 渐变尺寸伸缩动画效果</li><li>TranslateAnimation 画面转换位置移动动画效果</li><li>AnimationSet 一个持有其它动画元素alpha、scale、translate、rotate或者其它set元素的容器</li></ul><p>插值器：</p><ul><li>LinearInterpolator：动画以均匀的速度改变</li><li>AccelerateInterpolator：在动画开始的地方改变速度较慢，然后开始加速</li><li>AccelerateDecelerateInterpolator：在动画开始、结束的地方改变速度较慢，中间时加速</li><li>CycleInterpolator：动画循环播放特定次数，变化速度按正弦曲线改变： Math.sin(2  mCycles  Math.PI * input)</li><li>DecelerateInterpolator：在动画开始的地方改变速度较快，然后开始减速</li><li>AnticipateInterpolator：反向，先向相反方向改变一段再加速播放</li><li>AnticipateOvershootInterpolator：开始的时候向后然后向前甩一定值后返回最后的值</li><li>BounceInterpolator： 跳跃，快到目的值时值会跳跃，如目的值100，后面的值可能依次为85，77，70，80，90，100</li><li>OvershottInterpolator：回弹，最后超出目的值然后缓慢改变到目的值</li></ul><h4 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h4><p>在res/anim下新建animation_tweened_test_rotate.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">rotate</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:duration</span>=<span class="string">"1000"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:fromDegrees</span>=<span class="string">"0"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:interpolator</span>=<span class="string">"@android:anim/accelerate_decelerate_interpolator"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:pivotX</span>=<span class="string">"50%"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:pivotY</span>=<span class="string">"50%"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:repeatCount</span>=<span class="string">"infinite"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:toDegrees</span>=<span class="string">"360"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>AnimationUtils.loadAnimation(Context context, @AnimRes int id)创建Animation，然后给指定的View调用view.startAnimation(Animation animation) view.clearAnimation()</p><h2 id="属性动画（Property-Animation）"><a href="#属性动画（Property-Animation）" class="headerlink" title="属性动画（Property Animation）"></a>属性动画（Property Animation）</h2><p>属性动画实现原理就是修改控件的属性值实现的动画。</p><p>核心类：android.animation.Animator</p><ul><li>Animator 创建属性动画的基类</li><li>ValueAnimator  Animator子类。其内部采用一种时间循环的机制来计算值与值之间的动画过度，我们只需将初始值以及结束值提供给该类，并告诉其动画所需时间长度，该类就会自动帮我们从初始值平滑过度到结束。该类还能管理动画的播放次数、模式和监听器等。</li><li>ObjectAnimator  ValueAnimator的子类，允许我们对指定对象的属性执行动画，用起来更简单，实际中用得较多。</li><li>AnimatorSet  Animator子类，可以组合多个Animator，并制定Animator的播放次序。</li><li>Interpolator 插值器，同补间动画。</li><li>Evaluator 计算器，告诉动画系统如何从初始值过度到结束值。提供了一下的几种Evaluator：</li></ul><p>IntEvaluator：用于计算int属性<br>FloatEvaluator：用于计算float属性<br>ArgbEvaluator：用于计算16进制表示颜色值的计算器<br>TypeEvaluator：上述计算类的公共接口，可以自己实现接口完成自定义</p><p>监听器：</p><p>AnimatorUpdateListener： 当值状态发生改变时候会回调onAnimationUpdate方法。</p><p>AnimatorListener、AnimatorListenerAdapter：</p><ul><li>onAnimationStart()：动画开始</li><li>onAnimationRepeat()：动画重复执行</li><li>onAnimationEnd()：动画结束</li><li>onAnimationCancel()：动画取消</li></ul><p>平常开发，属性动画多使用ValueAnimator和ObjectAnimator。<br>ValueAnimator有个缺点，就是只能对数值对动画计算。<br>为了能让动画直接与对应控件相关联，以使我们从监听动画过程中解放出来，可以使用ValueAnimator的子类ObjectAnimator。</p><p>使用ObjectAnimator实现动画也有一些要求和限制：</p><ol><li>动画显示的属性必须带有一个 setter 方法（以骆驼拼写法命名）。 因为 ObjectAnimator 会在动画期间自动更新属性值，它必须能够用此 setter 方法访问到该属性。 例如：假设属性名称为color，则需要有一个setColor()方法。</li><li>如果在调用 ObjectAnimator 的某个工厂方法时，我们只为 values… 参数指定了一个值，那此值将被认定为动画属性的结束值。 这样的话，动画显示的属性必须带有一个 getter 方法，用于获取动画的起始值。例如：假设属性名为color，则需要有一个getColor()方法。</li><li>动画属性的 getter 方法（如果必要的话）和 setter 方法所操作数据的类型必须与 ObjectAnimator 中设定的起始和结束值相同。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Android中动画划分为两大类 视图动画（View Animation）和 属性动画（Property Animation）。其中 属性动画（Property Animation）需要在Android3.0之后（API &amp;gt;= 11）使用。&lt;br&gt;视图动画（View 
      
    
    </summary>
    
      <category term="Android" scheme="https://codepoem.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="https://codepoem.github.io/tags/Android/"/>
    
      <category term="动画" scheme="https://codepoem.github.io/tags/%E5%8A%A8%E7%94%BB/"/>
    
  </entry>
  
</feed>
